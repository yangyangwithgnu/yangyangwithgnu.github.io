<!DOCTYPE html>
<html>

    <head>
     
        <title>美丽新世界：LINUX 下的惬意生活</title>
     
        <meta charset="UTF-8" http-equiv="X-UA-Compatible" content="IE=8" />
        
        <link href="../../../css/all.css" type="text/css" rel="stylesheet" />
        
    </head>

    <body>
     
    <div class="sample">
        <!--当前在线人数-->
        <script language="JavaScript"> 
            var ref = (''+document.referrer+'');
            var w_h = window.screen.width + " x " + window.screen.height;
            document.write('<script src="http://freehostedscripts.net/ocounter.php?site=ID3995775&e1=Online User&e2=Online Users&r=' + ref + '&m=0&wh=' + w_h + '"><\/script>'); 
        </script>
        
        <!--访问人数-->
        <script language="JavaScript" src="http://freehostedscripts.net/ocount.php?site=ID2487263&name=Visits"></script>
     
        <a href="mailto:yangyang.gnu@gmail.com">yangyang.gnu@gmail.com</a>
    </div>

        <h1>美丽新世界：LINUX 下的惬意生活</h1>
        
        
        <br /><br /><hr class="version"><br /><br />
        <ul>
            <li>v0.1（2014-3-19）：完成初版编制</li>
        </ul>

        <br /><br /><hr class="index" /><br />
        <div class="index">
            <a href="#index_0">0&nbsp;发行套件<br /></a>
            <a href="#index_0_1">&nbsp;&nbsp;&nbsp;&nbsp;0.1&nbsp;发行套件的选择<br /></a>
            <a href="#index_0_2">&nbsp;&nbsp;&nbsp;&nbsp;0.2&nbsp;发行套件的安装<br /></a>
            <a href="#index_0_3">&nbsp;&nbsp;&nbsp;&nbsp;0.3&nbsp;发行套件的设置<br /></a>
            <a href="#index_0_3_1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.3.1&nbsp;升级系统<br /></a>
            <a href="#index_0_3_2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.3.2&nbsp;安装驱动<br /></a>
            <a href="#index_0_3_3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.3.3&nbsp;美化桌面<br /></a>
            <a href="#index_1">1&nbsp;日常办公<br /></a>
            <a href="#index_1_1">&nbsp;&nbsp;&nbsp;&nbsp;1.1&nbsp;办公文书<br /></a>
            <a href="#index_1_2">&nbsp;&nbsp;&nbsp;&nbsp;1.2&nbsp;电邮收发<br /></a>
            <a href="#index_1_3">&nbsp;&nbsp;&nbsp;&nbsp;1.3&nbsp;电子书阅读<br /></a>
            <a href="#index_1_3_1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.1&nbsp;pdf 阅读<br /></a>
            <a href="#index_1_3_2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.2&nbsp;chm 阅读<br /></a>
            <a href="#index_2">2&nbsp;娱乐休闲<br /></a>
            <a href="#index_2_1">&nbsp;&nbsp;&nbsp;&nbsp;2.1&nbsp;歌曲聆听<br /></a>
            <a href="#index_2_2">&nbsp;&nbsp;&nbsp;&nbsp;2.2&nbsp;电影观赏<br /></a>
            <a href="#index_2_3">&nbsp;&nbsp;&nbsp;&nbsp;2.3&nbsp;音频编辑<br /></a>
            <a href="#index_3">3&nbsp;上网冲浪<br /></a>
            <a href="#index_3_1">&nbsp;&nbsp;&nbsp;&nbsp;3.1&nbsp;无线上网<br /></a>
            <a href="#index_3_2">&nbsp;&nbsp;&nbsp;&nbsp;3.2&nbsp;网页浏览<br /></a>
            <a href="#index_3_3">&nbsp;&nbsp;&nbsp;&nbsp;3.3&nbsp;搭梯翻墙<br /></a>
            <a href="#index_3_3_1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.1&nbsp;封锁原理<br /></a>
            <a href="#index_3_3_2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2&nbsp;在线网页代理<br /></a>
            <a href="#index_3_3_3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.3&nbsp;google&nbsp;服务器代理<br /></a>
            <a href="#index_3_3_4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.4&nbsp;VPN&nbsp;代理<br /></a>
            <a href="#index_3_3_5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.5&nbsp;地下网络代理<br /></a>
            <a href="#index_3_4">&nbsp;&nbsp;&nbsp;&nbsp;3.4&nbsp;资源下载<br /></a>
            <a href="#index_3_5">&nbsp;&nbsp;&nbsp;&nbsp;3.5&nbsp;网上购物<br /></a>
            <a href="#index_3_6">&nbsp;&nbsp;&nbsp;&nbsp;3.6&nbsp;即时通讯<br /></a>
            <a href="#index_4">4&nbsp;系统管理<br /></a>
            <a href="#index_4_1">&nbsp;&nbsp;&nbsp;&nbsp;4.1&nbsp;数据备份<br /></a>
            <a href="#index_4_2">&nbsp;&nbsp;&nbsp;&nbsp;4.2&nbsp;碎片整理<br /></a>
            <a href="#index_5">5&nbsp;图形图像<br /></a>
            <a href="#index_5_1">&nbsp;&nbsp;&nbsp;&nbsp;5.1&nbsp;图片编辑<br /></a>
            <a href="#index_5_2">&nbsp;&nbsp;&nbsp;&nbsp;5.2&nbsp;色彩提取<br /></a>
            <a href="#index_5_3">&nbsp;&nbsp;&nbsp;&nbsp;5.3&nbsp;屏幕截图<br /></a>
            <a href="#index_5_4">&nbsp;&nbsp;&nbsp;&nbsp;5.4&nbsp;屏幕录像<br /></a>
            <a href="#index_6">6&nbsp;其他杂项<br /></a>
            <a href="#index_6_1">&nbsp;&nbsp;&nbsp;&nbsp;6.1&nbsp;蓝牙收发<br /></a>
            <a href="#index_6_2">&nbsp;&nbsp;&nbsp;&nbsp;6.2&nbsp;手机管理<br /></a>
            <a href="#index_6_3">&nbsp;&nbsp;&nbsp;&nbsp;6.3&nbsp;英文翻译<br /></a>
            <a href="#index_6_4">&nbsp;&nbsp;&nbsp;&nbsp;6.4&nbsp;中文输入<br /></a>
            <a href="#index_6_5">&nbsp;&nbsp;&nbsp;&nbsp;6.5&nbsp;软件开发<br /></a>
            <a href="#index_6_6">&nbsp;&nbsp;&nbsp;&nbsp;6.6&nbsp;虚拟终端<br /></a>
            <a href="#index_6_7">&nbsp;&nbsp;&nbsp;&nbsp;6.7&nbsp;升级BIOS<br /></a>
            <a href="#index_6_8">&nbsp;&nbsp;&nbsp;&nbsp;6.8&nbsp;有待提升<br /></a>
            <a href="#index_7">7&nbsp;完结<br /></a>
        </div>

        <br /><br /><hr class="content" /><br />


        <p>LINUX，从深海潜艇到高空侦察机、从房间大的工作站到手掌小的手机、从远至美国的 google 服务器到近在客厅的机顶盒，你都能见到它的身影。我无意说服你抛弃娴熟使用的操作系统，假如你不满现有系统的保守封闭，假如你崇尚自由、渴求本质、热爱折腾，不妨试试 LINUX！</p>

        <h2 id="index_0">0、发行套件</h2>

        <p>LINUX 本身还算不上操作系统，它仅是内核（一方面管理协调下层的硬件资源，一方面为上层软件提供基础服务支撑），需搭配系统软件（shell、编译器、包管理器、桌面环境等等）、应用软件（办公软件、网页浏览器、视频播放器、图片编辑器等等）才能成为一套具备日常使用功能的操作系统，即，发行套件。</p>

        <h3 id="index_0_1">0.1 发行套件的选择</h3>

        <p>LINUX 发行套件种类繁多（约 140 种）、用途迥异（如，专供盲人使用的、专供教育培训使用的、专用于家庭影院使用的），对每个发行套件逐一评测、比对选优，完全是费神耗时、意义不大。目前，知名的发行套件包括：puppy、slackware、debian、fedora、arch、gentoo、ubuntu、lfs、openSUSE 等，它们各具特色、追随者众，如，slackware 是目前存活时间最长的古董级发行套件（经验丰富），fedora 是 redhat 进行新技术实验的发行套件（技术创新），ubuntu 号称用户零配置开箱即用的发行套件（简单易用）、lfs（LINUX from scratch）让你从无到有构建个人专属的发行套件（配置灵活）、经验丰富+技术创新+简单易用+配置灵活 = openSUSE！（~_~#）</p>
        <p>openSUSE 最早是 slackware 在德国的本地化版本，后来因其加入了大量特色功能升格为单独的发行套件，其原名为 suse LINUX，从 10.2 版本开始更名为 openSUSE。openSUSE 由 novell 公司赞助、社区推动的发行套件，它的相关源码和技术可由 novell 使用，作为 novell 企业版发行套件 SLES 的基础。openSUSE 旨在：a）推进 LINUX 在全球广泛使用；b）降低LINUX使用门槛，成为易于上手的发行套件；c）成为技术黑客和软件开发人员的首选平台。openSUSE 的 logo 是只可爱的变色龙，以此象征 openSUSE 灵活、敏捷的特性。</p>
        <img src="./imgs/logo.png" />
        <p class="img_descr">（logo）</p>
        <p>openSUSE 当前（2012-8）正式版本为 12.1，下个版本 12.2 预计在 9 月中旬发布。关于发行套件版本升级，通常我会在最新正式版放出半年后再考虑，原因有二：一方面经过半年的大规模外部用户测试，大部分 bug 已被发现并修正，一定程度上规避了使用系统的不稳定性；一方面各类应用软件开发人员有足够时间针对新版本的发行套件进行功能升级和兼容性优化，让我真真正正感受到新版本带来的各项提升。所以，今年暂时不升级了，明年 3 月份再考虑。</p>

        <h3 id="index_0_2">0.2 发行套件的安装</h3>

        <p>既然是普通用户使用的发行套件，势必集成了某种桌面环境以便用户通过可视化界面操作计算机（LINUX 最底层由 x.org 提供图形图像服务，中间由桌面环境负责统一管理各应用软件发起的图形绘制请求并协调 x.org 予以响应）。openSUSE 12.1 提供 gnome 和 kde 两种桌面环境供君选择（此外，还有 xfce、lxde、ede、rox 等等其他桌面环境可单独下载安装）。gnome 是隶属 GNU 项目群的子项目，全称为 the gnu network object model environment，采用 GTK（由 C 语言编写）作为底层开发库；KDE 全称kool desktop environment，采用 QT（由 C++ 语言编写）作为底层开发库。gnome 和 kde 是 LINUX 中最为流行的桌面环境，从操作习惯和界面风格来看，我更喜欢 gnome。因此，本文将以采用 gnome 的 openSUSE 12.1 为例进行后文讲解。</p>
        <p>下载镜像。访问 software.openSUSE.org/121/en，选择 gnome、32位（或64位视情况而定）直接下载即可；</p>
        <p>制作安装 U 盘。U 盘安装既节省光盘介质费用，又能大幅提升安装速度，逐渐成为你安装系统的首选。官网上提供了制作 openSUSE 安装 U 盘的工具 imagewriter，分为windows版本（github.com/downloads/openSUSE/kiwi/imagewriter.exe）和 LINUX（software.opensuse.org/package/imagewriter?search_term=imagewriter）版本。windows版有个小bug，下载的镜像文件扩展名为 iso，而 imagewriter 在选择镜像文件时只能识别扩展名为 raw 的文件，所以需先调整镜像文件扩展名才能正常写入 U 盘；</p>
        <p>
            安装系统。整个过程一路 next，除了几个关键点稍加留意外，基本零难度，参照如下几步。（注，安装过程中，部分窗口过小，无法查看窗口中完整内容，可用鼠标拖动窗口边框以调整合适大小）
            <ul>
                <li>
                时区设置。如果你是冏朝公民，按下图设置，其中必须勾选“将硬件时钟设置为utc”，否则时间有问题：
                <img src="./imgs/时区设置.png" />
                <p class="img_descr">（时区设置）</p>
                </li>
                <li>
                    创建分区。建议依次创建如下分区：/、swap、/home、/data。说明几点：<br /><br />
                    <ul>
                        <li>LINUX 的分区不同于 windows，分区后没有所谓的 C:、D: 盘，而是一个个文件系统，这些文件系统没有具体名称，必须先挂载到某个目录（称之为挂载点）下才能正常使用，分区与目录一一对应；</li>
                        <li>
                        操作系统为扩展物理内存容量通常设有“虚拟内存”机制，将不活波内存页（如，未关闭但长时间没使用的程序）从物理内存移至硬盘的虚拟内存，从而释放宝贵的物理内存空间，swap 分区就是所谓的虚拟内存，一般将其容量规划得等同于物理内存，但，只有在物理内存吃紧时（如，启用多个大型程序、运行了存在严重泄漏的程序）系统才会使用 swap，换言之，如果你机器物理内存较大（如，4G），也不一定非要将 swap 分区划为与物理内存一样大，给个2G让系统应急即可。另外，由于不存在由用户直接发起的swap分区读写的场景，所以该分区不用挂载目录，由系统自行管理。如果想查看 swap 实时使用情况，可执行“vmstat 1”命令，输出信息中，si 表示 1 秒内写入 sawp 的内存页大小，so 从 swap 中读出的内存页大小，单位为 K；
                        <img src="./imgs/查看swap使用情况.png" />
                        <p class="img_descr">（查看swap使用情况）</p>
                        </li>
                        <li>用户相关信息（如，应用程序的配置文件）通常放在 /home 目录中，为避免重装系统导致各类配置文件丢失，需将 /home 放在独立分区上。应用程序配置文件通常位于如下路径：~/.[app_name]、~/.config/、~/.local/share/、~/.local/share/applications/、/etc/[app_name].conf，但，有时重装、升级系统或应用程序后，发现程序运行异常，可先删除相关配置文件再试试；</li>
                        <li>所有非系统数据（如，歌曲、ebook、安装程序）都放在独立分区 /data 上，以便定期备份。</li>
                    </ul>
                    按提示操作后，出现如下分区界面：
                    <img src="./imgs/硬盘分区.png" />
                    <p class="img_descr">（硬盘分区）</p>
                </li>
                <li>
                安装前确认。正式安装系统前，可对先前安装设置信息进行确认、调整。如下图所示：
                <img src="./imgs/安装前确认.png" />
                <p class="img_descr">（安装前确认）</p>
                </li>
                <li>
                系统引导设置。openSUSE 为防止因异常导致系统无法正常启动，除安装“真正操作系统”之外，还附带安装了所谓的“紧急启动镜像”，个人觉得意义不大，如果不需要，可点击“booting”，可删除紧急启动镜像：
                <img src="./imgs/紧急启动镜像.png" />
                <p class="img_descr">（紧急启动镜像）</p>
                另外，双击 openSUSE 12.1（真正的操作系统），参照如下设置，分别取消启动时硬盘检查和设置字符模式下的分辨率：
                <img src="./imgs/引导设置：取消硬盘检查、设置字符模式分辨率.png" />
                <p class="img_descr">（引导设置：取消硬盘检查、设置字符模式分辨率）</p>
                此外，进入“boot loader installation”->“boot loader options”，取消引导程序等待用户选择操作系统耗时：
                <img src="./imgs/引导设置：取消引导等待.png" />
                <p class="img_descr">（引导设置：取消引导等待）</p>
                </li>
            </ul>
        </p>


        <h3 id="index_0_3">0.3 发行套件的设置</h3>

        <p>刚装好的操作系统都是默认设置，按个人习惯适当调整才贴心。</p>

        <h4 id="index_0_3_1">0.3.1 升级系统</h4>

        <p>LINUX 上系统升级分两部分，一部分是内核升级，一部分是发行套件升级（即，除内核外的驱动程序、系统软件、应用软件等升级）。</p>

        <h5>内核升级</h5>

        <p>
            升级内核是为了享受新内核带来的安全增强、更多设备支持、以及各类新特性，有两种可选方式：方式一，如果熟悉内核编译选项，那么你完全可以针对自己的设备编译出最大程度发挥设备性能的定制版内核，另文详讲；方式二，如果不具备这些知识，也别急，openSUSE提供了几种常见场景的预编译内核，在软件仓库中选择中意的版本，安装、重启即可。常见的预编译内核包括：
            <ul>
                <li>kernel-default 是系统默认版内核，这是保守选择，能保证在所有设备上成功启用操作系统；</li>
                <li>kernel-pae 在 kernel-default 基础上增加了“物理地址扩增”功能，支持识别大于3G的物理内存设备（最多支持至 64G）；</li>
                <li>kernel-desktop 在 kernel-pae 基础上针对桌面进行优化，并屏蔽了只有服务器上才会使用的内核功能；</li>
                <li>kernel-syms 含有内核源码符号，如变量名、函数名、结构名，便于内核跟踪调试；</li>
                <li>kernel-vanilla 是纯净版内核，清除了发行套件自行添加的补丁。</li>
            </ul>
            通常来说，选用 kernel-desktop 较合适。
        </p>
        <p>
            安装新内核，执行
            <div class="sample">
                zypper in kernel-desktop
            </div>
            这时，你系统中将存在两个内核，kernel-default 和 kernel-desktop，如果系统中存在了多个可用到内核，那就需要有个地方去记录、管理内核列表 —— /boot/grub2/grub.cfg，该文件中存放了不同版本内核列表，大概结构如下：<br /><br />
            <div class="sample">
                ###&nbsp;BEGIN&nbsp;/etc/grub.d/10_LINUX&nbsp;###&nbsp;<br />
                menuentry&nbsp;'openSUSE&nbsp;12.2'&nbsp;…<br />
                {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;...<b>AAA</b>...<br />
                }<br />
                submenu&nbsp;'Advanced&nbsp;options&nbsp;for&nbsp;openSUSE&nbsp;12.2'&nbsp;…<br />
                {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;menuentry&nbsp;'openSUSE&nbsp;12.2,&nbsp;with&nbsp;LINUX&nbsp;3.4.11-2.16-default'&nbsp;…<br />
                &nbsp;&nbsp;&nbsp;&nbsp;{<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />
                &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                &nbsp;&nbsp;&nbsp;&nbsp;menuentry&nbsp;'<b>openSUSE&nbsp;12.2,&nbsp;with&nbsp;LINUX&nbsp;3.4.11-2.16-desktop</b>'&nbsp;…<br />
                &nbsp;&nbsp;&nbsp;&nbsp;{<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<b>BBB</b>...<br />
                &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                }<br />
            </div>
            假定希望选用 kernel-desktop 版内核，那么将“openSUSE 12.2, with LINUX 3.4.11-2.16-desktop”后花括弧内容全部拷贝覆盖至“openSUSE 12.2”花括弧内，调整后该文档结构大致如下：<br /><br />
            <div class="sample">
                ###&nbsp;BEGIN&nbsp;/etc/grub.d/10_LINUX&nbsp;###&nbsp;<br />
                menuentry&nbsp;'openSUSE&nbsp;12.2'&nbsp;…<br />
                {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;...<b>BBB</b>...<br />
                }<br />
                submenu&nbsp;'Advanced&nbsp;options&nbsp;for&nbsp;openSUSE&nbsp;12.2'&nbsp;…<br />
                {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;menuentry&nbsp;'openSUSE&nbsp;12.2,&nbsp;with&nbsp;LINUX&nbsp;3.4.11-2.16-default'&nbsp;…<br />
                &nbsp;&nbsp;&nbsp;&nbsp;{<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />
                &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                &nbsp;&nbsp;&nbsp;&nbsp;menuentry&nbsp;'<b>openSUSE&nbsp;12.2,&nbsp;with&nbsp;LINUX&nbsp;3.4.11-2.16-desktop</b>'&nbsp;…<br />
                &nbsp;&nbsp;&nbsp;&nbsp;{<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<b>BBB</b>...<br />
                &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                }<br />
            </div>
            重启，下次系统将默认选用 kernel-desktop 版内核。登录系统后执行<br /><br />
            <div class="sample">
                uname -r
            </div>
            可查看当前使用的内核版本，执行<br /><br />
            <div class="sample">
                less /proc/meminfo
            </div>
            可查看系统识别的物理内存（输出第一行 MemTotal 字段中显示）。
        </p>

        <h5>发行套件升级</h5>

        <p>在进行发行套件升级前，先说说软件仓库。前面说过，发行套件是集成内核、驱动程序、系统软件、应用程序等一整套可支撑普通用户日常工作、生活需求的操作系统，可见，发行套件充当了软件筛选、软件打包、软件依赖库测试、软件兼容性测试等多个角色，为确保发行套件的健壮性，发行套件厂商（或社区）将它筛选、打包、测试过的软件放在官方软件仓库中，这样，不论哪个厂商开发的应用程序，用户只需到软件仓库中查找、下载、安装即可，不用（像 windows）再到各个软件官网逐一下载，当然，软件仓库中没有的，你仍可到软件官网单独下载，但要注意依赖库是否正确。软件仓库一般放在发行套件官方服务器上，用户通过更新源访问软件仓库。因此，更新源就是软件仓库的路牌。好了，了解了软件仓库、更新源等概念后，我们可以按如下步骤升级发行套件啦。</p>
        <p>第一步，添加更新源。更新源的选择一定要严谨，尽量选择针对你使用的特定发行套件（甚至版本）且经过严格兼容性测试的源，这些更新源中收录的软件可能不是最新的但一定是最稳定的。基于这一思想，除了开启发行套件自带的几个默认官网更新源外，我仅新增显卡驱动和 packman 两个更新源。具体运行 yast -> software repositories -> add-> specify rul，填入 ftp://download.nvidia.com/openSUSE/12.1即可实现添加nvidia显卡驱动更新源，类似，填入 http://packman.inode.at/suse/12.1实现packman更新源的添加（packman，第三方更新源，收录了大量经过严格测试的新软件）。</p>
        <p>
            此外，还有四类源，收录了大量新版本软件以及囧朝专用软件，在让你品尝新功能以及满足本地化需求的同时，可能会引入系统稳定性和软件兼容性问题，清谨慎添加：
            <ul>
                <li>
                增加社区制作的各类更新源。这是大而全的更新源合辑，你需要的 99% 软件均可在此找到，其中，也包括前面添加的显卡驱动（A 卡和 N 卡）和 packman 更新源。具体操作，选择 community repositories，勾选所有源后保存即可。系统在加载这些更新源时，会提示是否信任从这些源中下载安装软件，选择“trust”，本来是再简单不过的一个操作，但由于系统 bug，该提示窗口过小，以至于无法正常显示出“trust”按钮，且手工也无法调整窗口大小，唯一可行的办法是“alt-t”快捷键选择“trust”，如下图所示：
                <img src="./imgs/是否信任该更新源.png" />
                <p class="img_descr">（是否信任该更新源）</p>
                </li>
                <li>增加官网 tumbleweed 更新源。tumbleweed收录了最新版本的软件，具体操作，选择http，输入如下地址即可：download.openSUSE.org/repositories/openSUSE:/Tumbleweed/standard</li>
                <li>增加官网 openSUSE_zh 更新源。该更新源收录了大量冏朝内供软件。download.openSUSE.org/repositories/home:/openSUSE_zh/openSUSE_12.1</li>
                <li>增加官网 M17N 更新源。该更新源收录了软件国际化、本地化等相关库文件。download.openSUSE.org/repositories/M17N/openSUSE_12.1</li>
            </ul>
        </p>
        <p>添加完更新源后，我们还应注意几点：注意点一、软件安装完成后自动删除安装程序，以节约存储空间，在software repositories中取消每个更新源的“keep downloaded packages”；注意点二、不同更新源中难免有重复的软件，这时，必须有个机制指示系统选用哪个源中版本——更新源优先级，优先级从1到200，数字越小优先级越高，系统优选优先级高的更新源中的软件，通常来说，收录的软件测试周期越长、测试越严格的更新源应第一优先，即，download.openSUSE.org/update/12.1/的优先级应置为1。</p>
        <p>另外，如果你的网络环境无法流畅访问境外官网软件仓库，可以转为访问其在朝内镜像。国内还有几家上规模又有良心的 IT 企业，通过企业自身带宽优势，准实时地从发行套件官网同步软件仓库到国内服务器上，冏朝用户可调整更新源，实现从这些企业的服务器上高速访问软件仓库。目前，为各大发行套件建立国内软件仓库镜像的企业有搜狐、东软，高校有北京交大、中国科大、中央音乐学院（歌唱艺术家也玩 LINUX ^…^），开源社区有 LUPA 等，以上机构均为 openSUSE.org 官方注册镜像，具体镜像地址参见mirrors.openSUSE.org；</p>
        <p>第二步，删除无用软件。系统默认安装的软件不见得都是你需要的（如，gnome 自带小游戏、某些软件自带的非中文和英文的帮助文档），进 install/remove software，取消待删除软件前的勾选框，apply 即可。</p>
        <p>
            第三步，升级系统。一旦指示系统启动升级，系统先在软件仓库（加载的所有更新源）中寻找是否有升级的可能。具体而言，存在三类升级方式：
            <ul>
                <li>命令 zypper update。对于本地已安装程序，如果软件仓库中有新版本，并且新老版本来至同个更新源、而且新老版软件构架相同（如 86_64、i686、noarch、i586 等等），那么才会执行软件升级操作，否则，即便发现新版，系统会提示类似如下信息“The following package updates will NOT be installed: chmsee”，以告知chmsee虽有新版本但系统不会为你更新。换言之，update 是个非常保守的参数，即便软件仓库中有新版本，该命令也不一定让你得到新版软件。当然，如果你非要安装，也可以先执行 zypper install chmsee 命令，但此时系统还不会真正升级软件，而是反馈你最新版本号为 1.99.08-32.3.i586，若你确定要升级必须执行 zypper install chmsee-1.99.08-32.3.i586；</li>
                <li>命令 zypper patch。为系统打补丁，这是提升系统安全性的重要一环，怒建阁下日常定期执行；</li>
                <li>命令 zypper dist-upgrade。将系统与软件仓库同步一致，也就是说，本地安装的软件必须只能是仓库中有的且版本必须一致，换言之，一旦执行该命令，将本地软件将存在软件降级（本地版本高而仓库版本低）、软件升级（本地版本低而仓库版本高）、卸载软件（本地安装而仓库没有）、安装软件（系统认为有用，也就是 zypper install-new-recommends 命令输出信息中罗列的软件）等几种可能，特别是当你有通过源码安装过软件时切勿使用该命令。</li>
            </ul>
        </p>
        <p>总之，以上三个命令差异巨大，就日常而言，建议：用 zypper patch 为系统打补丁，用 zypper update 升级软件，用 zypper install program_version_num 升级 zypper update 无法升级的软件；</p>


        <h4 id="index_0_3_2">0.3.2 安装驱动</h4>

        <p>windows 环境中增加了硬件，通常需要到硬件官网下载驱动，安装重启后系统才能识别新增硬件设备，LINUX 对驱动的管理，你可以（片面地）理解为全都打包进内核中了，只要是内核版本足够新（这正是前面升级内核的目的之一），99% 的硬件完全可以识别，换言之，你不用针对主板、芯片、（有/无线）网卡、显卡、声卡、甚至 G3 上网卡（后文将教你如何在 LINUX 下使用运营商的上网卡）单独安装驱动，因为内核已经集成了它们的驱动，当然，我指的是集成驱动能很好地管理对应硬件设备，如果管理得不是那么好呢？那也可以单独安装，比如，N 卡驱动。openSUSE 预置了 N 卡驱动程序的开源版 nouveau，nouveau 由第三方开发，并未得到 nvidia 官方支持，是开发人员对 N 卡官方驱动逆向分析后的重新编码，实现难度巨大，虽效果不尽人意但也值得你尊重。作为普通用户，肯定希望最大程度发挥显卡特性，那就安装 N 卡针对 openSUSE 发布的（闭源）官方显卡驱动吧。先增加 N 卡官方更新源 ftp://download.nvidia.com/openSUSE/12.1 ，再执行前面讲的升级命令即可。</p>

        <h4 id="index_0_3_3">0.3.3 美化桌面</h4>

        <p>前面提过，我选装的是 gnome 桌面环境。gnome3 相较先前版本，不论从界面外观还是操作习惯都有非常大的差异，比如，窗口右上角只有关闭按钮，不再有最大化、最小化的概念；比如，托盘从任务栏中剥离出来，默认情况下为隐藏状态；比如，要选择桌面上的某个窗口，先得调出所有窗口的列表，在点击选择需要的那个；比如，不再有桌面图标，等等。如此这些，让很多人无法适应、被人诟病。也许是心态问题，我倒是挺适应这种操作模式的，使用 gnome3 也有三年多时间了，虽谈不上驾轻就熟，但也不存在任何使用障碍，非要让我提一点意见的话，嗯～嗯～，好吧，真心希望 gnome 开发团队将横向布局的任务栏改为纵向布局，至于原因，你知道，如今的显示器几乎都是宽屏的，这就意味着屏幕的水平空间充裕而垂直空间紧张，现在又将任务栏水平放置在最顶部，进一步缩小了可用垂直空间，所以，强烈建议<b>将任务栏垂直放置在屏幕左侧</b>（效果类似 ubuntu 的 unity），希望下一版本能有所改善。另外，个人认为，对于一项新生事物（我说的是 gnome3），不妨以“拥抱变化、迎接未来”的心态去尝试，或许，你会发现，原来它才是你的最爱。</p>
        <p>扯远了，接着说 gnome 的美化。桌面美化，无非就是选一套符合你审美观的主题，具体包括窗口主题、图标主题、光标主题、图形环境登录界面、系统声音等等，下载、安装、启用即可。</p>
        <p>
            第一步，预准备。主题安装不像想的那么容易，为确保不同发行套件下均能安装成功，请提前作好如下准备：
            <ul>
                <li>安装时机：主题应尽量在安装完所有软件后再安装，否则可能出现部分软件与当前主题无法适配的情况；</li>
                <li>各版本 GTK 库：GTK、GTK2、GTK3 等三个版本等基础库必须事前安装；</li>
                <li>
                    主题引擎：murrine、unico、adwaita、canvas、pixbuf 等几类主题引擎必须安装。除 pixbuf 外，其他引擎在安装源里均有，pixbuf 相对麻烦些，需要从 gnome-look.org/content/show.php/gtk2-engine-pixbuf%20%28Patched%29?content=77783 下载源码，但不能按其网页上介绍的方式安装，应调整为：
                    <div class="sample">
                        ./autogen.sh&nbsp;&amp;&amp;&nbsp;make&nbsp;&amp;&amp;&nbsp;make&nbsp;install<br />
                    </div>
                    如果安装主题后存在滚动条粗大、按钮错位等情况，再把 gtk2-engine-*、gtk3-engine-* 安装上；
                </li>
                <li>安装路径。一般而言，主题文件和图标分别放至全局目录 /usr/share/themes/ 和 /usr/share/icons/，或者分别放至账号目录 ~/.themes 和 ~/.icons 均可。建议优选全局目录，账号目录有一定几率导致主题失效；</li>
            </ul>
        </p>
        <p> 第二步，下载主题。推荐两个 gnome3 相关的主题网站：gnome-look.org 与 LINUX-lounge.deviantart.com，慢慢选，喜欢哪个下哪个。个人非常喜欢那种扁、平、薄的风格，GTK 主题选用 Numix（tiheum.deviantart.com/art/Faenza-Icons-173323228）（访问不了？对滴，你知道网上有一堵墙，搜索本文后面的“搭梯翻墙”），搭配 faenza 图标主题（tiheum.deviantart.com/art/Faenza-Icons-173323228）效果非常不错。 </p>
        <p> 第三步，安装主题。将相关主题拷贝至 /usr/share/themes/ 和 /usr/share/icons/ 目录即可。具体而言，GTK 主题 Numix 解压后的 Numix/、Numix - GTK3.4/ 目录拷贝至 /usr/share/themes/，faenza 图标主题解压后得到压缩文件 Faenza.tar.gz、Faenza-Dark.tar.gz、Faenza-Darker.tar.gz、Faenza-Darkest.tar.gz 分别再解压后得到 Faenza、Faenza-Dark、Faenza-Darker、Faenza-Darkest 等四个目录拷贝至 /usr/share/icons/ 目录。注意，a）如果无法选择对应主题，请确认是否多套了一层目录；b）/usr/share/themes/ 和 /usr/share/icons/ 目录中系统自带主题和图标切勿删除，否则将导致无法登录图像界面； </p>
        <p>
            第四步，选择主题。运行 advanced settings，参照下图选择窗口和图标主题： 
            <img src="./imgs/选择主题.png" />
            <p class="img_descr">（选择主题）</p>
        </p>
        <p>
            第五步，启用主题。键入 alt+f2，输入 r 回车，看到没，刚才选择的主题已经生效。最终效果如下：
            <img src="./imgs/GNOME3-HOLO.png" />
            <p class="img_descr">（gnome3-holo）</p>
        </p>
        <p>
            第六步，字体美化。openSUSE 中文显示默认采用文泉驿字体，相比之下，更喜欢微软雅黑那种方方正正的饱满字体，但微软雅黑中的英文字体又不咋地，有人发布了一款增强了英文字体的微软雅黑——yahei consolas hybrid 字体，可以下来试试，效果非常不错（本文全文采用的就是这种字体）。双击字体按提示安装，安装完后进入 advanced settings，按如下设置即可：
            <img src="./imgs/字体设置.png" />
            <p class="img_descr">（字体设置）</p>
        </p>
        <p>
            第七步，动态壁纸。GNOME3改变了很多传统用户习惯，淡化桌面概念就算之一，默认不再有桌面图标、无法将窗口最小化到任务栏、没有返回桌面按钮，99% 时间你看到的是某个应用程序的全屏窗口，体现了“内容至上”的理念，正因为此，GNOME3 中不再有动态壁纸功能，用户只有 1% 的时间可能看到桌面墙纸，动态壁纸功能理当下线——GNOME3 设计人员托梦告诉我滴 ~_~。如果你仍然迷恋动态壁纸，可以通过如下方式实现：
            <ol start="0">
                <li>
                首先实现基础功能。将如下 shell 代码拷贝至 auto_wallpaper.sh 文件，其中，两处的 /data/misc/software/misc./gnome3/wallpaper/ 替换为你存放图片的目录，4096 替换成你希望间隔多少秒自动切换一次墙纸（why 4096? that is 2^12, and that is 68m :-）
                <div class="sample">
                    #!/bin/bash&nbsp;<br />
                    cd&nbsp;/data/misc/software/misc./gnome3/wallpaper/&nbsp;<br />
                    while&nbsp;[&nbsp;1&nbsp;]&nbsp;<br />
                    &nbsp;&nbsp;do&nbsp;<br />
                    &nbsp;&nbsp;set&nbsp;-&nbsp;*&nbsp;<br />
                    &nbsp;&nbsp;length=$#&nbsp;<br />
                    &nbsp;&nbsp;random_num=$((&nbsp;$RANDOM&nbsp;%&nbsp;($length&nbsp;+&nbsp;1)&nbsp;))&nbsp;<br />
                    &nbsp;&nbsp;gsettings&nbsp;set&nbsp;org.gnome.desktop.background&nbsp;picture-uri&nbsp;"file:/data/misc/software/misc./gnome3/wallpaper/${!random_num}"&nbsp;<br />
                    &nbsp;&nbsp;sleep&nbsp;4096&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;68分钟变化一次桌面墙纸&nbsp;<br />
                    done<br />
                </div>
                </li>
                <li>
                    接着实现停止动态壁纸。先找到 auto_wallpaper.sh 脚本的进程 ID（严格地说，应该是启动该脚本的父 shell 进程 ID）：
                    <div class="sample">
                        LINUX-asze:~&nbsp;#&nbsp;ps&nbsp;-ef&nbsp;|&nbsp;grep&nbsp;auto_wallpaper&nbsp;<br />
                        root&nbsp;3027&nbsp;1&nbsp;0&nbsp;16:58&nbsp;?&nbsp;00:00:00&nbsp;/usr/bin/gnome-terminal&nbsp;-x&nbsp;/bin/sh&nbsp;-c&nbsp;'/data/misc/software/misc./gnome3/wallpaper/auto_wallpaper.sh'<br />
                    </div>
                    直接杀掉该脚本：
                    <div class="sample">
                        kill -9 3027
                    </div>
                </li>
                <li>
                    最后实现自动启动。将如下代码拷贝至 auto_wallpaper.desktop，并将该文件移至 ~/.config/autostart/ 目录。其中，/data/misc/software/misc./gnome3/wallpaper/auto_wallpaper.sh 替换为上面保存的 auto_wallpaper.sh 文件多绝对路径：
                    <div class="sample">
                        [Desktop&nbsp;Entry]&nbsp;<br />
                        Name=auto_wallpaper&nbsp;<br />
                        Exec=/data/misc/software/misc./gnome3/wallpaper/auto_wallpaper.sh&nbsp;<br />
                        Comment=change&nbsp;wallpaper&nbsp;every&nbsp;so&nbsp;often&nbsp;<br />
                        Hidden=false&nbsp;<br />
                        Type=Application&nbsp;<br />
                        X-GNOME-Autostart-enabled=true<br />
                    </div>
                </li>
            </ol>
        </p>
        <p>说了这么多，作为普通用户，我们关注的还是 openSUSE 如何支撑我们的日常工作、生活需求。接下来看看，那些借助社区力量开发的优秀开源产品。（注，未特别说明，以下介绍的软件均可通过软件仓库查找、下载、安装）</p>
        <p>如果你需要的软件在添加的各类软件仓库中都无法找到，可依次尝试如下两个专用搜索引擎：software.openSUSE.org/search 和 www.rpmfind.net，若还是无法找到，只有借助通用搜索引擎找到该软件官网，再下载安装。</p>


        <h2 id="index_1">1 日常办公</h2>

        <p>现在的企事业单位几乎都需借助电脑办公，医生看病开处方、营业厅办理业务、会计帐务处理等等，电脑已成为各行各业办公的主要途径和手段。下面介绍几类常见的办公需求。</p>

        <h3 id="index_1_1">1.1 办公文书</h3>

        <p>word、excel、powerpoint 等三个软件是 windows 中必装的办公文书软件，以支撑我们文字处理、表格制作、汇报演示等工作需要。LINUX 中我们对应有writer、calc、impress 等软件，这三个软件（外加 draw、math、base）就是大名鼎鼎的 libreoffice 套件。libreoffice 完全兼容 ms-office 文档，甚至还可以直接转存为 pdf 格式文件，</p>
        <p>软件名称：libreoffice</p>
        <p>
            界面截图：
            <img src="./imgs/Writer.png">
            <p class="img_descr">（writer）</p>
            <img src="./imgs/Calc.png" />
            <p class="img_descr">（calc）</p>
            <img src="./imgs/Impress.png" />
            <p class="img_descr">（impress）</p>
        </p>
        <p>设置调整：tools -> options -> language settings -> writing aids，取消 options 中的所有选项，以禁止拼写检查。</p>

        <h3 id="index_1_2">1.2 电邮收发</h3>

        <p>很多人喜欢通过邮件服务提供商官网进行邮件收发，强烈建议改用邮件客户端，避免频繁登录邮箱，同时，还能离线查阅邮件内容。好的邮件客户端除了正常收发邮件外，还应具备地址簿管理、垃圾邮件过滤、多账户管理、日程安排、同步删除远程邮件，甚至为常见邮件提供商智能配置等等高级功能，thunderbird 算是不错的。</p>
        <p>软件名称：thunderbird</p>
        <p>
            界面截图：
            <img src="./imgs/thunderbird.png" />
            <p class="img_descr">（thunderbird）</p>
            <img src="./imgs/写邮件.png" />
            <p class="img_descr">（写邮件）</p>
        </p>

        <h3 id="index_1_3">1.3 电子书阅读</h3>
        <p>电子书格式类型较多，包括 hlp、lit、wdl、ceb、abm、pdg、epub、pdf、chm 等等，但常见的还是最后两类。下面介绍下 pdf 和 chm 的阅读器。</p>

        <h4 id="index_1_3_1">1.3.1 pdf 阅读</h4>

        <p>世上有三件事你无法回避：死亡、税收、阅读 pdf 文档。</p>
        <p>软件名称：evince</p>
        <p>
            界面截图：
            <img src="./imgs/evince.png" />
            <p class="img_descr">（evince）</p>
        </p>
        <p>
            使用问题：你知道，正常情况下，被选中的文本段会反色高亮显示，估计是 evince 本地化问题（未用 unicode 编码 -_-??），某些中文 pdf 文档，反色显示的文字会成乱码，虽不影响真正复制到粘贴板中的内容（换言之，从 evince 中复制出来的文字仍正常），但一定程度上影响了我等喜欢选中一段看一段的用户阅读体验。如下图所示：
            <img src="./imgs/未选前的文本.png" />
            <p class="img_descr">（未选前的文本）</p>
            <img src="./imgs/选中后的文本.png" />
            <p class="img_descr">（选中后的文本）</p>
        </p>
        <p>
        其他说明：推荐几个常用的软件开发相关电子书下载网站：
        <ul>
            <li>www.it-ebooks.info</li>
            <li>www.freetechbooks.com</li>
            <li>ishare.iask.sina.com.cn</li>
        </ul>
        </p>
        <p>另外，我对 pdf 修改也有使用需求。很遗憾，LINUX 下并无稳定、高质量的 pdf 修改开源工具，上古时代的 pdftk、flpsed、pdfedit 一众古董完全派不上场，pdf studio 算是唯一功能达标的，但又是闭源共享软件，不推荐。既然修改不了 pdf，添加注释总可以吧，xournal 就是满足这一需求的软件。</p>
        <p>软件名称：xournal</p>
        <p>
            界面截图：
            <img src="./imgs/PDF修改.png" />
            <p class="img_descr">（PDF修改）</p>
        </p>

        <h4 id="index_1_3_2">1.3.2 chm 阅读</h4>

        <p>虽然 chm 文档越来越少，但难免还是会遇到，有两个工具可阅读 chm：chmsee 和 kchmviewer。</p>
        <p>软件名称：chmsee；</p>
        <p>
            界面截图：
            <img src="./imgs/chmsee.png" />
            <p class="img_descr">（chmsee）</p>
        </p>


        <h2 id="index_2">2 娱乐休闲</h2>

        <p>LINUX 不是 IT 大牛的专属系统，它不仅可以支撑生产运维，同时，也可为你提供日常休闲娱乐。</p>

        <h3 id="index_2_1">2.1 歌曲聆听</h3>
        <p>常见的音频格式包括：mp3、ogg、aac、mp4、ape、wav、flac 等，windows 下知名的音频播放器 foobar2000 完美支持这些格式，LINUX 下的 deadbeef 从解码效果来看，有过之而无不及。</p>
        <p>软件名称：deadbeef</p>
        <p>
            界面截图：
            <img src="./imgs/deadbeef.png" />
            <p class="img_descr">（deadbeef）</p>
        </p>
        <p>
            使用问题：
            <ul>
                <li>一般来说，通过软件仓库安装某个软件，系统会自动关联安装依赖库，以保障软件正常运行，但，deadbeef 依赖的必要插件 deadbeef-restricted-plugins 并未自动关联，需手工自行添加，否则 deadbeef 无法加载歌曲；</li>
                <li>要让当前播放曲目显示在播放列表窗口中可以：ctrl-j 快捷键，或者，菜单中选择playback -> scroll follows playback；</li>
                <li>随机播放算法有问题，列表中歌曲数目较多（>=1000）时，随机命中歌曲始终就那么几十首，所以，我一般把歌曲分为几个播放列表，每个列表不超过 512 首；</li>
            </ul>
        </p>

        <h3 id="index_2_2">2.2 电影观赏</h3>

        <p>我看电影有个习惯，喜欢把电影全屏铺满后再看，这样不至于在如今满是宽屏幕的环境中把人物压缩得又扁又胖。另外，针对视频文件名类似的多个文件要能连续播放（也就是连续自动播放连续剧）。LINUX 下找了一圈都没发现满意的，包括大名鼎鼎的 vcl 和mplayer，直到有天我遇到 umplayer。umplayer 是基于 mplayer 二次开发的软件，默认支持（即内置相关格式解码器） mkv、wmv、avi、mpg、3gp、mov、rm、mpeg、mp4 等视频格式。</p>
        <p>软件名称：umplayer</p>
        <p>
            界面截图：
            <img src="./imgs/普通比例.png" />
            <p class="img_descr">（普通比例）</p>
            <img src="./imgs/全屏铺满.png" />
            <p class="img_descr">（全屏铺满）</p>
        </p>
        <p>设置调整：全屏铺满设置：video -> aspect ratio -> disabled；</p>
        <p>使用问题：全屏纵向拉伸设置只能针对单部影片有效，无法保持为永久设置，播放其他影片需要重新设置；</p>
        <p>
            其他说明：推荐两个不错的电影下载网站：
            <ul>
                <li>人人影视：www.yyets.com</li>
                <li>电影天堂：www.dy2018.com</li>
            </ul>
        </p>

        <h3 id="index_2_3">2.3 音频编辑</h3>

        <p>听到一首喜欢的歌曲，想把它设置为手机来电铃声，但整首歌曲又太长，最好能把高潮部分提取出来，一来电就进入高潮（-_-$，你想啥～）。</p>
        <p>软件名称：audacity；</p>
        <p>
            界面截图：
            <img src="./imgs/Audacity.png" />
            <p class="img_descr">（audacity）</p>
        </p>


        <h2 id="index_3">3 上网冲浪</h2> 

        <p>问：宅男最怕失去啥？答：网络（谁说苍老师？@_@！）。网络在给我们带来无限乐趣的同时，也在不断地改变着人类生活方式。</p>

        <h3 id="index_3_1">3.1 无线上网</h3>

        <p>目前无线上网形式包括：adsl+无线路由器方式、wlan 方式、3g 上网卡方式。第一种是大家平时最常见的方式，找运营商开通宽度，自己买个无线路由器，将宽度帐号和密码设置进路由器，加电即用，该方式上网速度快，但受空间限制较大，一旦超过路由器信号覆盖就无法上网了；第二种方式需要先联系电信运营商开通 wlan 业务，联网后在运营商提供的页面输入帐号和密码即可上网，这种方式上网速度还是不错，但，费用高（按流量收费）、择区域（只有在热点附近才能使用wlan业务，通常小城市热点非常少，即便大城市也往往只有机场、星巴克等场所才有）；第三种方式，3g上网卡方式，网速基本可接受（可在线观看非高清视频），包月费用约 100rmb，将上网卡插入电脑，随时随地即可高速上网，这里为大家详细介绍下这种方式。3g 上网卡有两个概念普及下，a）当前中电信、中联通、中移动等三家运营商均有提供各自 3g 上网卡，分别采 cdma2000、wcdma、td 等三种网络制式，网速、费用、稳定性各不相同；b）华为、中兴两家是主流的卡设备提供商。运营商、设备请按个人情况选择，我用的是华为中移动 g3 上网卡，下文将以此为例进行介绍。</p>
        <p>华为 g3 上网卡官方仅发布了 windows 驱动，LINUX 下咋办？前面介绍升级内核时我提过，windows 与 LINUX 对驱动的管理存在较大差异，windows 需用户针对各个硬件单独下载、安装驱动，而 LINUX 在内核中已经集成了（绝大部分）硬件设备驱动程序（别争论宏内核和微内核），包括，这里说的华为中移动 g3 上网卡驱动。</p>
        <p>大致原理如下：LINUX 能识别 g3 上网卡，但默认将其视为 usb 存储设备，我们需要告诉系统说“它是一个网络拨号 moden，不是 U 盘”，一旦系统接受了该设备模式转换请求，后续只需用某种拨号程序执行拨号操作即可。</p>
        <p>先准备两个命令行程序：usb_modeswitch、wvdial，直接从软件仓库中安装。以下操作均在命令行中执行，全流程步骤如下：</p>
        <p>
            第一步，获取 g3 上网卡 usb 信息。执行：<br /><br /> 
            <div class="sample">
                lsusb | grep "Huawei"
            </div>
            系统显示类似如下 <br /><br />
            <div class="sample">
                bus 002 device 003: id 12d1:1da1 huawei technologies co., ltd. 
            </div>
            记录下你对应 12d1:1da1 位置的信息，<b>后续步骤中凡是出现 12d1:1da1 均用此查看到的这两个值进行替换</b>；（完整 USB ID 列表请见：www.LINUX-usb.org/usb.ids）
        </p>
        <p>第二步，g3 上网卡模式转换。</p>
        <p>
            首先，指定要进行模式转换的设备。文件 /etc/usb_modeswitch.conf 中的内容用如下信息覆盖，注意替换你设备信息： 
            <div class="sample">
                DefaultVendor=0x12d1
                DefaultProduct=0x1da1
                TargetVendor=0x12d1 
                TargetProduct=0x1da1 
                HuaweiMode=1
            </div>
        </p>
        <p>
            然后，进行模式转换操作。执行：
            <div class="sample">
                usb_modeswitch -c /etc/usb_modeswitch.conf 
            </div>
            显示如下信息<br /><br /> 
            <div class="sample">
                looking&nbsp;for&nbsp;target&nbsp;devices&nbsp;...&nbsp;<br />
                &nbsp;found&nbsp;devices&nbsp;in&nbsp;target&nbsp;mode&nbsp;or&nbsp;class&nbsp;(1)&nbsp;<br />
                ...<br />
                <br />
                scsi&nbsp;inquiry&nbsp;data&nbsp;(for&nbsp;identification)&nbsp;<br />
                -------------------------&nbsp;<br />
                &nbsp;&nbsp;vendor&nbsp;string:&nbsp;huawei&nbsp;<br />
                &nbsp;&nbsp;&nbsp;model&nbsp;string:&nbsp;mobile&nbsp;cmcc&nbsp;cd&nbsp;<br />
                revision&nbsp;string:&nbsp;1.25&nbsp;<br />
                -------------------------&nbsp;<br />
                <br />
                usb&nbsp;description&nbsp;data&nbsp;(for&nbsp;identification)&nbsp;<br />
                -------------------------&nbsp;<br />
                manufacturer:&nbsp;huawei&nbsp;mobile&nbsp;<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product:&nbsp;huawei&nbsp;mobile&nbsp;system&nbsp;solution&nbsp;<br />
                &nbsp;&nbsp;serial&nbsp;no.:&nbsp;111111-11-111111&nbsp;<br />
                -------------------------&nbsp;<br />
                sending&nbsp;huawei&nbsp;control&nbsp;message&nbsp;...&nbsp;<br />
                &nbsp;ok,&nbsp;huawei&nbsp;control&nbsp;message&nbsp;sent&nbsp;<br />
                -&gt;&nbsp;run&nbsp;lsusb&nbsp;to&nbsp;note&nbsp;any&nbsp;changes.&nbsp;bye.&nbsp;<br />
            </div>
            注，这一步执行过程可能僵死，重新插入上网卡重新执行该步骤； 
        </p>
        <p>
            接着，确认转换完成。执行第一步命令显示如下信息 
            <div class="sample">
                bus 002 device 009: id 12d1:1d09 huawei technologies co., ltd. 
            </div>
            如果先前的 1da1 变为 1d09 那么恭喜你，关键一步已经成功了； 
        </p>
        <p>
            最后，查看设备信息。执行： 
            <div class="sample">
                ls /dev/ttyA* 
            </div>
            输出信息为 <br /><br />
            <div class="sample">
                /dev/ttyACM0  /dev/ttyACM1  /dev/ttyACM2 
            </div>
            那就转换成功了；
        </p>
        <p>第三步，拨号上网。</p> 
        <p>
            首先，生成 g3 上网卡拨号配置文件。执行： 
            <div class="sample">
                wvdialconf
            </div>
            输出 <br /><br />
            <div class="sample">
                editing&nbsp;`/etc/wvdial.conf'.&nbsp;<br />
                scanning&nbsp;your&nbsp;serial&nbsp;ports&nbsp;for&nbsp;a&nbsp;modem.&nbsp;<br />
                modem&nbsp;port&nbsp;scan&lt;*1&gt;:&nbsp;s0&nbsp;s1&nbsp;s2&nbsp;s3&nbsp;<br />
                wvmodem&lt;*1&gt;:&nbsp;cannot&nbsp;get&nbsp;information&nbsp;for&nbsp;serial&nbsp;port.&nbsp;<br />
                ttyacm0&lt;*1&gt;:&nbsp;atq0&nbsp;v1&nbsp;e1&nbsp;--&nbsp;ok&nbsp;<br />
                ttyacm0&lt;*1&gt;:&nbsp;atq0&nbsp;v1&nbsp;e1&nbsp;z&nbsp;--&nbsp;ok&nbsp;<br />
                ...<br />
                ...<br />
                ttyacm2&lt;*1&gt;:&nbsp;speed&nbsp;460800:&nbsp;at&nbsp;--&nbsp;ok&nbsp;<br />
                ttyacm2&lt;*1&gt;:&nbsp;max&nbsp;speed&nbsp;is&nbsp;460800;&nbsp;that&nbsp;should&nbsp;be&nbsp;safe.&nbsp;<br />
                ttyacm2&lt;*1&gt;:&nbsp;atq0&nbsp;v1&nbsp;e1&nbsp;s0=0&nbsp;&amp;c1&nbsp;&amp;d2&nbsp;+fclass=0&nbsp;--&nbsp;ok&nbsp;<br />
                <br />
                found&nbsp;an&nbsp;usb&nbsp;modem&nbsp;_disibledevent=0&nbsp;&amp;c1&nbsp;&amp;d2&nbsp;+fclass=0"&nbsp;<br />
                ttyacm1&lt;info&gt;:&nbsp;speed&nbsp;460800;&nbsp;init&nbsp;"atq0&nbsp;v1&nbsp;e1&nbsp;s0=0&nbsp;&amp;c1&nbsp;&amp;d2&nbsp;+fclass=0"&nbsp;<br />
                ttyacm2&lt;info&gt;:&nbsp;speed&nbsp;460800;&nbsp;init&nbsp;"atq0&nbsp;v1&nbsp;e1&nbsp;s0=0&nbsp;&amp;c1&nbsp;&amp;d2&nbsp;+fclass=0"&nbsp;<br />
            </div>
        </p>
        <p>
            然后，修改拨号配置文件。用如下内容替换 /etc/wvdial.conf 文件： 
            <div class="sample">
                [Dialer&nbsp;Defaults]&nbsp;<br />
                Init1&nbsp;=&nbsp;ATZ&nbsp;<br />
                Init2&nbsp;=&nbsp;ATQ0&nbsp;V1&nbsp;E1&nbsp;S0=0&nbsp;&amp;C1&nbsp;&amp;D2&nbsp;+FCLASS=0&nbsp;<br />
                Password&nbsp;=&nbsp;any&nbsp;<br />
                Phone&nbsp;=&nbsp;*99***1#&nbsp;<br />
                Modem&nbsp;Type&nbsp;=&nbsp;USB&nbsp;Modem&nbsp;<br />
                Stupid&nbsp;Mode&nbsp;=&nbsp;1&nbsp;<br />
                Baud&nbsp;=&nbsp;460800&nbsp;<br />
                New&nbsp;PPPD&nbsp;=&nbsp;yes&nbsp;<br />
                Modem&nbsp;=&nbsp;/dev/ttyACM0&nbsp;<br />
                ISDN&nbsp;=&nbsp;0&nbsp;<br />
                username&nbsp;=&nbsp;any<br />
            </div>
        </p>
        <p>
            最后，执行拨号联网。执行： 
            <div class="sample">
                wvdial 
            </div>
            输出 <br /><br />
            <div class="sample">
                &lt;div&nbsp;class="sample"&gt;<br />
                --&gt;&nbsp;wvdial:&nbsp;internet&nbsp;dialer&nbsp;version&nbsp;1.60&nbsp;<br />
                --&gt;&nbsp;cannot&nbsp;get&nbsp;information&nbsp;for&nbsp;serial&nbsp;port.&nbsp;<br />
                --&gt;&nbsp;initializing&nbsp;modem.&nbsp;<br />
                --&gt;&nbsp;sending:&nbsp;atz&nbsp;<br />
                atz&nbsp;<br />
                ok&nbsp;<br />
                --&gt;&nbsp;sending:&nbsp;atq0&nbsp;v1&nbsp;e1&nbsp;s0=0&nbsp;&amp;c1&nbsp;&amp;d2&nbsp;+fclass=0&nbsp;<br />
                atq0&nbsp;v1&nbsp;e1&nbsp;s0=0&nbsp;&amp;c1&nbsp;&amp;d2&nbsp;+fclass=0&nbsp;<br />
                ok&nbsp;<br />
                --&gt;&nbsp;modem&nbsp;initialized.&nbsp;<br />
                --&gt;&nbsp;sending:&nbsp;atdt*99***1#&nbsp;<br />
                --&gt;&nbsp;waiting&nbsp;for&nbsp;carrier.&nbsp;<br />
                atdt*99***1#&nbsp;<br />
                connect&nbsp;2800000&nbsp;<br />
                --&gt;&nbsp;carrier&nbsp;detected.&nbsp;starting&nbsp;ppp&nbsp;immediately.&nbsp;<br />
                --&gt;&nbsp;starting&nbsp;pppd&nbsp;at&nbsp;mon&nbsp;jun&nbsp;22&nbsp;11:11:50&nbsp;2009&nbsp;<br />
                --&gt;&nbsp;pid&nbsp;of&nbsp;pppd:&nbsp;4134&nbsp;<br />
                --&gt;&nbsp;using&nbsp;interface&nbsp;ppp0&nbsp;<br />
                --&gt;&nbsp;local&nbsp;ip&nbsp;address&nbsp;10.140.162.111&nbsp;<br />
                --&gt;&nbsp;remote&nbsp;ip&nbsp;address&nbsp;192.200.1.21&nbsp;<br />
                --&gt;&nbsp;primary&nbsp;dns&nbsp;address&nbsp;221.130.33.60&nbsp;<br />
                --&gt;&nbsp;secondary&nbsp;dns&nbsp;address&nbsp;221.130.33.52&nbsp;<br />
                --&gt;&nbsp;connected...&nbsp;press&nbsp;ctrl-c&nbsp;to&nbsp;disconnect&nbsp;<br />
            </div>
        </p>
        <p>
            好了，就是这样。如果是第一次使用 3G 上网卡，那么需要依次执行以上每步，后续只需执行 wvdial 命令即可拨号联网（有时 3G 信号不稳定，需要重复多次执行 wvdial 命令）。另外，有时拨号会报错 warning, no nameserver found `/etc/resolv.conf`，该信息表明 DNS 未正确设置，这就需要先清空 /etc/resolv.conf 文件内容，再添加如下两行：
            <div class="sample">
                nameserver&nbsp;211.137.96.205&nbsp;<br />
                nameserver&nbsp;211.137.82.4&nbsp;<br />
            </div>
            保存，重新执行 wvdial 拨号即可。（在普通宽带连接异常时，也可尝试该方法）
        </p>

        <h3 id="index_3_2">3.2 网页浏览</h3>
        <p>浏览器是互联网入口，各大互联网公司必争之地。opera、chrome、firefox 三大浏览器，opera 功能上没有多少过人之处且不开源，丢之；chrome 虽有开源版本 chromium，但很多插件都仅支持 windows 平台而在 LINUX 下无法使用（包括google自己出品的 Chrome Toolbox），弃之；firefox，开源且以 LINUX 为第一阵营，凭借其高安全性和可扩充性赢得大量忠实用户。</p>
        <p>软件名称：firefox；</p>
        <p>
            界面截图：
            <img src="./imgs/firefox.png" />
            <p class="img_descr">（firefox）</p>
        </p>
        <p>你对 firefox 的任何需求，几乎都可以通过其丰富的插件资源得到满足（另一个有如此庞大插件资源的软件当数 vim 了，后面有介绍）。进入 tools -> add-ons 即可在线查找需要的插件，找到后点击在线安装即可，安装完成需重启浏览器以让新装插件生效。下面介绍几款我觉得非常有用的插件。</p>
        <p>
            <b>下载管理</b>，download statusbar。完全替代 firefox 自带的下载管理器，它可以实时查看下载进度、可以直接打开下载完的文件、可以根据当前下载速度用不同颜色高亮提示等等。如下图，第一个文件已下载完毕，第二个正在下载，实时速度为 167.2K、下载进度为 19%、橙色背景表示速度在 200K 以下，若达到 600K 则会显示为绿色：
            <img src="./imgs/download statusbar.png" />
            <p class="img_descr">（download statusbar）</p>
        </p>
        <p>
            <b>对象拖拽</b>，quickdrag。若拖拽链接则直接打开，若拖动文本则在当前搜索引擎中搜索。如下图所示：
            <img src="./imgs/对象拖拽插件 quickdrag.gif" />
            <p class="img_descr">（对象拖拽插件 quickdrag）</p>
            另外，我不太喜欢立即激活新页面，本来 firefox 中有个选项（preferences -> tabs -> when I open a link in a new tab, switch to it immediately）可用于此设置，但长年无效，只能直接修改它的配置项：地址栏中输入 about:config，查找 browser.tabs.loadDivertedInBackground 配置项，双击使其为 true 即可。
        </p>
        <p>
            <b>鼠标手势</b>，all-in-one gestures。我常用的右键向左拖动表示退回、向右拖动表示前进。如下所示：
            <img src="./imgs/鼠标手势插件 all-in-one gestures.gif" />
            <p class="img_descr">（鼠标手势插件 all-in-one gestures）</p>
        </p>
        <p><b>双击关闭 tab</b>，close tab by double click。无须多说，个人习惯；</p>
        <p>
            <b>侧边显示</b>，all-in-one sidebar。将收藏夹、下载管理、插件管理、访问历史等统一收纳到侧边条中，如下图所示：
            <img src="./imgs/all-in-one sidebar.png" />
            <p class="img_descr">（侧边显示插件 all-in-one sidebar）</p>
        </p>
        <p>
            <b>恢复关闭页面</b>，Undo Closed Tabs Button。下载安装好后，先要通过 customize 将 undo 图标拖动到 firefox 工具栏中才能看到。如下图所示：
            <img src="./imgs/恢复关闭页面插件 Undo Closed Tabs Button.gif" />
            <p class="img_descr">（恢复关闭页面插件 Undo Closed Tabs Button）</p>
        </p>
        <p>
            <b>flash 播放</b>。目前几乎所有在线视频、在线文库等网站都通过 flash 实现（亲，我说的通过浏览器直接访问，我知道你 iphone 也可以观看在线视频，但那是通过安装本地app 观看，与这儿说的事情没啥干系），常逛这类网站的朋友必须得装 flash 插件才能正常访问。adobe 不给力，导致很多浏览器加载 flash 文件时失败，提示 the adobe flash plugin has crashed：
            <img src="./imgs/flash插件报错.png" />
            <p class="img_descr">（flash插件报错）</p>
        </p>
        <p>很是奇怪，老版 firefox 搭配老版 flash 正常，升级 firefox 和 flash 后就无法显示，简单思维下，只可能是 firefox 与 flash 版本冲突。为了解决 firefox 播放 flash 报错的问题，我决定先从 flash 版本问题入手，先把 adobe 官网上 30 多个 flash 历史版本全拉下来，依次验证哪个版本的可用，经过 8 分 32 秒，遇到了 flash player 10.1.85.3 的 debug 版本（fpdownload.macromedia.com/get/flashplayer/installers/archive/fp_10.1.85.3_and_9.0.283_archive.zip），哇～，就它了，在线文库、视频测试都正常。赶紧把这个版本的库文件 libflashplayer.so 备份下来，以备不时之需，以后，一旦再出问题，用该库文件覆盖 /usr/lib/browser-plugins/libflashplayer.so 重启 firefox 即可正常显示 flash。亲，没事可千万别升级 flash 插件哟。</p>
        <p>另外，如果你用的是 chromium 则不太可能出现 flash 显示问题。这是因为 google 与 adobe 合作开发了一项称之为 pepper API 的新技术，google 自家的 chromium 肯定支持 pepper，这就使得 flash 可以以插件的形式运行在 chromium 浏览器中。包括 firefox 在内的其它浏览器则不支持这项技术，因此也就不能无法播放 flash。</p>
        <p>听闻 adobe 公告，从 11.2 以后不再支持 LINUX 平台，唉，乔帮主英明，adobe 要自掘坟墓咱也别劝他，全当在给 HTML5 腾位置吧。</p>
        <p><b>在线视频下载</b>，Download YouTube Videos as MP4。随着网络视频的繁荣，国外的 YouTube、国内的 PPTV 等一大批视频网站上沉淀了很多有价值的视频，考虑到天朝宽带不宽的现状，为了不影响观影体验，我有很强的驱动力将在线视频下载到本地。</p>
        <p>
            YouTube 上的视频，可由插件 Download YouTube Videos as MP4 实现下载。安装好该插件重启 firefox 后，进入某个具体视频页面，在视频左下角多了个 Download 按钮，点击该按钮你将看到不同分辨率的视频下载地址列表，见下图：
            <img src="./imgs/YouTube 在线视频下载插件 Download YouTube Videos as MP4.png" />
            <p class="img_descr">（YouTube 在线视频下载插件 Download YouTube Videos as MP4）</p>
        </p>
        <p>PPTV 上的视频，可以通过硕鼠网（www.flvcd.com）在线解析，此外，硕鼠还可以解析优酷、土豆、奇艺等等几乎国内所有大型视频网站。</p>
        <p><b>添加搜索引擎</b>，Add to Search Bar。互联网是个巨大的知识库，你需要的任何知识都可以从中获取，前提是有个给力的搜索引擎。在我看来，好的搜索引擎应该：检索范围广泛、收录页面快速、检索结果无屏蔽、原创内容优先、智能分析相似关键字。</p>
        <p>
            搜索引擎如何选择？根据搜索内容的不同，我会依次使用如下几个引擎进行查找：
            <ul>
                <li>英文资料，先 www.duckduckgo.com 后 www.google.com，前者剔重算法完胜后者。（从大陆发起的访问自动被转向到香港服务器 www.google.com.hk，要访问美国服务器可用如下网址 www.google.com/ncr，其中，ncr 为 no country redirect，即不根据访问请求发起国家进行重定向，第一次访问该地址后相关信息将记录进 cookie 中，后续只要没清空 cookie，www.google.com 访问的都是 google 美国服务器）；</li>
                <li>中文技术资料，先 tw.search.yahoo.com 后 www.google.com.tw（百毒？没听过^o^）；</li>
            </ul>
        </p>
        <p>
            啰嗦几句，台湾人的技术文章多以原创为主，不像冏朝清一色的转载，特别是，很多国外经典计算机书籍引入冏朝后，被所谓的大学教授翻译得比日文还难读（《thinking in c++》，多经典的一本书，翻译得老子想骂人），这时，可以考虑找对应台译版（台版《thinking in c++》由蔡明志先生翻译），虽说有些术语叫法不同，但基本体现了著作愿意。如果你要用台湾搜索引擎查找技术资料，得注意以下几点：
            <ul>
                <li>tw.search.yahoo.com 和 www.google.com.tw（及其搜索结果均）均为墙外网站，要想正常访问必须搭梯，具体参见后文“搭梯翻墙”；</li>
                <li>为提高搜索命中率，尽量用台湾术语（如，面向对象-物件导向）；</li>
                <li>务必输入繁体字（可在 ibus 输入法中设置），否则将会很多朝内搜索结果；</li>
            </ul>
            另外，但凡中译书籍，建议直接海购繁体中文版，前面说过台湾人翻译的质量远胜囧朝，再次悲哀 :-(。
        </p>
        <p>话外音，国外将冏朝中文叫作 simplified chinese，而将台湾中文叫作 traditional chinese，也就是说，在老外眼里，冏朝用的是删减后的中文，而台湾用的才是老祖宗传下来的纯正传统中文。</p>
        <p>
            添加搜索引擎。安装好 Add to Search Bar，在搜索引擎首页的输入框中右键，选择 add to search bar 即可，如下图所示：
            <img src="./imgs/Add to Search Bar.png" />
            <p class="img_descr">（Add to Search Bar）</p>
            添加后，在浏览器的搜索引擎列表中查看所有搜索引擎：
            <img src="./imgs/搜索引擎列表.png" />
            <p class="img_descr">（搜索引擎列表）</p>
        </p>
        <p>搜索操作习惯。你可以在 firefox 右上角的搜索引擎列表中选择喜欢的引擎直接搜索，也可以在页面上（借助 quickdrag）直接拖拽要搜索的关键字启用当前引擎进行搜索；</p>
        <p><b>代理开关</b>，Autoproxy。Autoproxy 本身不具备代理功能，它通过一个在线配置文件，实时分析用户发起的网站访问请求中，哪些必须走代理访问、哪些可以直接访问。具体请见“搭梯翻墙”章节，Autoproxy 辅助 GoAgnet 可实现完美翻墙。</p>


        <h3 id="index_3_3">3.3 搭梯翻墙</h3>
        <p>google 重新发明了搜索引擎，苹果重新发明了手机，天朝重新发明了局域网。为让大家保有天朝优越感，+- 屏蔽了大量“非法”的网站，有境内/境外的、有纯技术的（至今我都没搞明白一个专注于开源项目的在线代码托管网站 sourceforge.net 哪儿有问题）、有爱情动作的、有轮子功的，反正 +- 不喜欢的通通借由 GFW 这堵墙屏蔽掉。裆从小就教育我们，哪里有压迫那里就有反抗，话说屏蔽之前，天朝的宅男还可以下载几部码片看看打发时间，嘚～～，看吧，让你屏蔽，没事做了，那就研究下怎样翻墙吧。</p>

        <h4 id="index_3_3_1">3.3.1 封锁原理</h4>
        <p>+- 最常用的封锁手段有二：关键字过滤、DNS 劫持。</p>
        <p>关键字过滤。你也别谈“滤”色变，全国时时刻刻这么大的网络流量交换，GFW 不可能做到全量、实时过滤分析，一是它没这么强悍的处理能力、二是这一过程严重影响网速。GFW 过滤，只能全网随机抽查，或者，有针对地对指定区域、指定 IP 进行，如果哪天你觉得小区里就你网速慢，恭喜，随机到你家。GFW 对选中 IP 的网络数据包进行实时解析，一旦发现敏感关键字，则短暂封锁终端 IP，导致所有网络访问中断。显然，要过滤关键字，必须满足数据包以明文传输这一必要条件。如果我们的浏览器支持加密访问网页，那么 GFW 永远不可能解析出关键字。默认情况下，我们通过 http 协议进行网页访问，这是明文，而 https 协议，则是密文。换言之，如果哪个浏览器默认支持 https，则可完全突破“关键字过滤”这种封锁手段 —— firefox；</p>
        <p>DNS 劫持。当用户输入 www.google.com 希望电信运营商解析出服务器真实 IP，以便访问 google，运营商在 +- 作用下停止解析这个URL，导致用户访问失败，这就是 DNS 劫持。针对这种封锁手段有两种解决方式：方式一，不依赖运营商而靠自己获取解析域名及其对应真实 IP；方式二，借助境外运营商进行域名解析。</p>
        <p>方式一，自己解析域名及其 IP，可以借助 SmartHosts 实现。SmartHosts（smarthosts.googlecode.com/svn/trunk/hosts），由众网友共同维护的一个 hosts 文件，里面存放着大量被墙域名及其 IP，将其内容追加到本地 /etc/hosts 文件中，此后，hosts 中罗列出的所有 URL 你可以正常高速访问了。但是，存在两个问题：A）SmartHosts 中的每条记录（URL 与 IP）都是各热心网友一条条手工添加的，不可能覆盖完所有被墙网站，肯定会出现一些你需要访问但又不在此列表中的网站；B）SmartHosts 更新周期不定，有时 3 天、有时 30 天，所以你需要不时去关注，有更新是及时添加至本地 hosts 文件中（最近更新时间 2013-12-07 12:16）。这种方式效果有限，你应该把精力放在方式二上。</p>
        <p>方式二，借助境外运营商进行域名解析，这是非常具有弹性的解决方案，只有它才能实现完美翻墙。接下来我将介绍四种基于这一思路发展出来的翻墙方式，每后一种均依赖前一种，你须依次了解，切勿跳越。</p>

        <h4 id="index_3_3_2">3.3.2 在线网页代理</h4>
        <p>对，就是最低端、最原始的在线网页代理，你可千万别看不起它，它是解开“翻墙死循环”的关键。什么是“翻墙死循环”？后面介绍的几种翻墙方法需要借助一些专用工具、证书文件，而这些工具均在墙外，也就是说，本来你想用这些工具实现翻墙，又不得不先翻墙才能下载这些工具，这就成了个死循环。所以，你得找到开启翻墙工具箱的原始方式 —— 在线网页代理。它就是一个网页，有个输入框，你把想要去的网站 URL 填入输入框后点击跳转即可达到目标网站。在 google 上搜索 free proxy sites，出来无穷多网站，依次尝试，其中大部分已无效，你得花时间多找找，总有可用的。你挑选的在线代理网页，第一肯定是要能无障碍访问墙外目标网页，第二必须支持目标网页上的文件下载（绝大部分在线代理网站不支持），第三如果可能的话速度尽可能快。我推荐 pakistanproxy.com（2014-3-18 测试有效，在线代理网页时效性非常短，一旦失效你得自己重新去找）。<b>本章节后续所有链接请务必通过这里的在线网页代理进行访问，否则十有八九你无法访问</b>。</p>
        <p>在线网页代理还行，基本零配置，解决了我 5% 的问题，但是，这类网站寿命较短，你需要经常去找新的可用的；另外，每次还得先把目标地址填入页面中的代理输入框，很麻烦；最担心的是，有些目标网站需要输入账号和密码，通过代理网页的话，难免存在安全隐患。我需要更安全稳定的代理。</p>

        <h4 id="index_3_3_3">3.3.3 google 服务器代理</h4>
        <p>google 有一套 WEB 应用程序引擎 Google App Engine（GAE），这套引擎部署在 google 自己位于美国的服务器上，全球任何开发人员可以向 google 申请使用该引擎。本来，这就一普通的开放服务而已，但是，在天朝这种网络环境下，思维发散的程序员发现：GAE 位于美国服务器上，程序员能在 GAE 上部署服务端程序，如果服务端能接收客户端发送过去的网页访问请求，那完全可以让服务端作为一个中转站，借助美国运营商进行域名解析（绕开朝内运营商），一旦获取网页数据后再传回给客户端。所以，GoAgent 诞生。</p>
        <p>GoAgent 实现了让 google 成为你的代理，高速且稳定访问所有被墙网站绝不是问题。当然，GoAgent 使用前提是能正常访问 google，前面介绍的 SmartHosts 已解决该问题，下面重点讲解。</p>
        <p>在进行具体操作前，先定义几个对象。GoAgent 包括客户端程序和服务端程序两部分，客户端程序简称为 GCP（GoAgent-client-programme），服务端程序简称为 GSP（GoAgent-server-programme），浏览器简称为 FF（firefox），墙外目标网站简称为 dest。GoAgent 实现的代理逻辑大致如下：FF 发起墙外 dest 网页访问请求，为绕开国内电信运营商，FF 走代理模式，将请求发至 GCP（127.0.0.1:8087），GCP 将请求转至 GSP，GSP 按 GCP 指示访问网站 dest，由于 GSP 位于美国，所以 GSP 可以顺畅地获取 dest 的网页，一旦 dest 的网页被 GSP 获取完整，GSP 立即传回给 GCP，GCP 再传给 FF，最终在 FF 中显示出完整页面。具体操作步骤如下：</p>
        <p>
            第一步，申请 GAE 空间，部属 GoAgent 服务端程序。用 google 帐号登录 appengine.google.com，前面步骤按提示填写，直到填写短信验证码步骤，朝内三家运营商都屏蔽了 google 的短信，你只能通过向 google 提交在线表单，请工作人员将验证码通过邮件发给你，访问 appengine.google.com/waitlist/sms_issues，表单填写内容大致如下：
            <div class="sample">
                hi,<br />
                my&nbsp;mobile&nbsp;phone&nbsp;can&nbsp;not&nbsp;receive&nbsp;sms&nbsp;for&nbsp;verification&nbsp;code!&nbsp;plz&nbsp;send&nbsp;the&nbsp;code&nbsp;to&nbsp;yangyang.gnu@gmail.com.&nbsp;thx&nbsp;man~<br />
            </div>
            2 小时 8 分 16 秒后收到回复：
            <img src="./imgs/GAE申请回复.png" />
            <p class="img_descr">（GAE申请回复）</p>
            昏，还验证个啥，工作人员直接就将 GAE 空间分配给我了（太给力了，效率啊）；
        </p>
        <p>第二步，下载 GoAgent。GoAgent 要操纵 GAE，就必须得有 GAE 的 SDK，而 GoAgent 是由 Python 编写的，所以得先下载 Python 版的 GAE SDK（developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python），这也是 GoAgent 所需的运行环境之一。下载后解压至 google_appengine/；接着下载 GoAgent（code.google.com/p/goagent），解压到 google_appengine/goagent/。</p>
        <p>第三步，修改服务端程序配置信息。既然是将 GoAgent 当作你自己开发的源码上传至 GAE，那么所有的 appid 都应替换成注册 GAE 时所写的应用程序名，比如，我注册时应用程序名设定的是 yangyanggnu，将 google_appengine/goagent/server/python/app.yaml 中的 application: 和 google_appengine/goagent/local/proxy.ini 文件中的 appid = 均改写为 yangyanggnu；</p>
        <p>
            第四步，上传部署服务端程序至 GAE。在 google_appengine/ 下执行：
            <div class="sample">
                python appcfg.py update goagent/server/python
            </div>
            整个过程耗时 1 分钟左右，如下图所示：
            <img src="./imgs/上传GoAgent至GAE.png" />
            <p class="img_descr">（上传 GoAgent 至 GAE）</p>
        </p>
        <p>第五步，设置浏览器代理地址。google_appengine/goagent/local/proxy.ini 文件中配置的监听 IP 为 127.0.0.1、端口为 8087，该信息表明，要走 GoAagent 代理，应将浏览器 firefox 的所有网站访问请求应发至 127.0.0.1:8087，那么，在 GoAagent 客户端程序 google_appengine/goagent/local/proxy.py 作用下，网页访问请求将通过 google 服务器代理访问。firefox 可通过 edit -> preferences -> advanced -> network -> connection -> settings 设置代理服务器地址为 127.0.0.1，端口为 8087，重启 firefox 即可生效。</p>
        <p>
            第六步，翻墙出城。至此，只要运行 GoAagent 的客户端程序 proxy.py，那么 firefox 的所有访问均通过 google 代理访问。进入 proxy.py 所在目录，执行
            <div class="sample">
                python google_appengine/goagent/local/proxy.py
            </div>
            将出现如下输出：
            <img src="./imgs/执行goagent本地代理程序.png" />
            <p class="img_descr">（执行 GoAgent 客户端程序）</p>
            接着，尝试用 firefox 访问墙外的 youtube.com，你会看到代理程序努力从 google 服务器上获取代理数据，如下图所示：
            <img src="./imgs/从google服务器上获取代理数据.png" />
            <p class="img_descr">（从 google 服务器上获取代理数据）</p>
            回头看看 firefox，咿～～，怎么会出现如下错误提示呢：
            <img src="./imgs/未导入证书.png" />
            <p class="img_descr">（未导入证书）</p>
            别担心，代理本身是成功的，这个错误是因未将 youtube.com 安全证书导入 firefox 所致。在 firefox 中，依次进入 edit -> preferences -> advanced -> encryption -> view certificates -> authorities ->import，选择导入证书google_appengine/goagent/local/CA.crt，重启 firefox 后，再访问 youtube.com 看看，呵呵，久违的 youtube.com 是不是又回来啦：）
            <img src="./imgs/youtube.png" />
            <p class="img_descr">（youtube）</p>
        </p>
        <p>
            对了，你可能发现访问 google 子域名有异常，这是因为 GoAgent 让所有 google 及其子域名默认不走代理。前面说过，GoAgent 生效的前提是客户端能正常访问google 服务器，理论上，访问 google.com 及其所有子域名都用不着走代理，即便在代理模式下，访问呢 google 子域名时 GoAgent 也根本不介入。但是，如果我又想通过代理访问某个 google 子域名怎么办？比如，想买 nexus 4，即便你开了 GoAgent，访问 play.google.com 会得到如下提示“Sorry! Devices on Google Play is not available in your country yet...”。前面提过，GoAgent 客户端程序的配置文件 google_appengine/goagent/local/proxy.ini，该文件中有两个 withgae 字段，该字段就是用于圈定那些强制走代理模式的 google 子域名。换言之，该字段指定那些属于 google.com但又强制走代理的子域名。在 proxy.ini 中所有 withgae 字段尾部追加 play.google.com 子域名，用 | 分割，即，...|play.google.com，保存 proxy.ini 后，重新运行 GoAgent 即可访问 play.google.com，如下图所示：
            <img src="./imgs/Nexus 4 (16GB) - Google Play.png" />
            <p class="img_descr">（Nexus 4 (16GB) - Google Play）</p>
        </p>
        <p>第七步，代理快速启停。上一步说过，到此我们所有网站访问请求都通过了 google 代理，这对那些没有被墙的网站访问场景来说未免多余，如果有个工具能实现当访问墙内网站时直接访问、访问墙外网站时走代理，那这个世界将变得更美好。想起前面讲 firefox 插件时提到的 autoproxy 么？对，autoproxy 就具备这种自适应代理的能力，请先自行下载安装 autoproxy，装好后，autoproxy 将以一个“福”字出现在 firefox 右上角，该插件屏蔽 firefox 自身的代理设置界面。首先，进入配置界面 proxy rule -> add rule subscription，选择 gfwList (P.R.China)，该文件中存放了部分加密后的被 +- 屏蔽的网址，以后，凡是在这个列表中的走代理，不在的直接访问；接着，进入 proxy server -> edit proxy server -> add proxy server，添加代理 GoAgent、IP 为 127.0.0.1、端口为 8087、协议 HTTP，重启firefox；最后，进入 proxy server -> edit proxy server -> choose proxy server，default proxy 选择 GoAgent、subscription 选择 gfwList (P.R.China)、when no matching 选择 no proxy。</p>
        <p>autoproxy 有三种模式，自适应模式（红色图标）、强制代理模式（绿色图标）、无代理模式（灰色图标）。自适应模式，就是我刚才说的，位于 gfwList (P.R.China) 中的网址走代理，不在其中的直接访问；强制代理模式，不管墙内墙外，访问所有网站均通过代理；无代理模式，就是不走代理全直接访问。由于 gfwList (P.R.China) 中记录的被墙网站数量有限，如果用自适应模式，那么大量不在此列表中的被墙网站你实际上用的无代理模式，肯定无法访问，所以，一般而言，优选强制代理模式。</p>
        <p>
            小结下，第一次可能麻烦点，如果以上七步都成功，那么你需要的免费、高速、稳定的梯子就已经制作完成。平时，需要翻墙，只需到 google_appengine/goagent/local/ 目录下执行
            <div class="sample">
                python google_appengine/goagent/local/proxy.py
            </div>
            即可，或者直接将其加入自启动项（GNOME 的启动项可通过在 CLI 中执行 gnome-session-properties 进行设置）。哦，差点忘了，google 限制 GAE 中一个应用每天流量不超过 1G，也就是说，你每天通过 GAE 代理访问流量不能超过 1G，一般情况是绝对够用了，如果的确有更多访问需求（如，通过代理下载电影），可以创建多个应用，每多创建一个应用则 google 多分配 1G 流量给你，可在“第三步，修改服务端程序配置信息”中用 | 将多个应用分割开，类似这样 yangyanggnu|yangyanggnu1|yangyanggnu2。
        </p>
        <p>至此，GoAgent 优雅地解决了浏览器翻墙的问题，加之前面的在线网页代理方式，解决了我 70% 的问题。对于绝大部分人来说，这已足够了，我的确很难归属到“绝大部分人”中，前面提到 GoAgent 只支持 HTTP(S) 协议代理，并不支持 socket 协议，也就是说，你只能翻墙看看墙外的各类网页，仅此而已，你无法让浏览器之外的软件翻墙。比如，Cygwin，一套用于将 LINUX 软件移至到 Windows 下的开发环境，在安装 Cygwin 时，它会自动联网下载环境中必须的头文件、编译器等等资源，而这些资源存放在墙外服务器上，Cygwin 又无法通过 HTTP 协议访问墙外资源，所以资源下载失败。换言之，GoAgent 实现的翻墙并非全局性的。我需要支持整个系统的全局代理。</p>

        <h4 id="index_3_3_4">3.3.4 VPN 代理</h4>
        <p>要实现整个系统的全局代理，你需要更生猛的翻墙利器 —— VPN。VPN（Virtual Private Network），初衷是为在外出差员工使用内网资源，虽然物理上是异构网络环境，但通过 VPN 虚拟成同一网络环境。为保障数据安全，VPN 服务端必须要有客户端发来的证书认证通过后才能进行数据交换，并且数据流全是加密传输，这一过程的副作用可以用于翻墙。</p>
        <p>
            VPN 协议有三种实现：PPTP、L2TP/IPsec、OpenVPN ，安全性最强（数字证书两端双向认证、256 位不可逆加密交换数据）、支持面最广（LINUX、BSD、OS X、WINDOWS、Android、iOS）、稳定性最高（完全无视防火墙的各类限制）当属  OpenVPN。可以在 openvpn.net/index.php/open-source/downloads.html （无法访问？用前面的 GoAgent 翻墙啊，多好的实践机会）下载最新版本 openVPN 源码（Android、iOS 版本请到各自 APP store 中搜索下载），源码安装、重启，系统中多出一个虚拟网卡设备，一旦运行 openvpn 程序，它会自动修改你系统的路由表，让所有网络数据请求优先走虚拟网卡，这就达到实现了全局代理的目的。现在，你需要找 VPN 服务提供商获取数字证书，嗨嗨嗨嗨，别走啊，免费的在这儿 www.vpngate.net/en，这里有全球各大非盈利机构开放给大家使用的免费 VPN 服务器，根据不同国家、不同带宽、不同性能你可以按需选用，比如，我选用位于日本、IP 为 59.159.29.165 的机器，点击该行 OpenVPN Config file 进入证书下载页面，找到类似 OpenVPN Configuration File: 59.159.29.165 (TCP 1865) 的链接点击即可下载得到 vpngate_118.70.187.48_tcp_1965.ovp 数字证书文件，接着运行
            <div class="sample">
                openvpn vpngate_118.70.187.48_tcp_1965.ovpn
            </div>
            进行 VPN 连接，出现 Initialization Sequence Completed 说明认证完成，OK，找个 IP 查询的网站（ip38.com）确认下访问 IP 是否变成日本的了。如果发现网站无法访问，或者网速太慢，可以换用其他 VPN 服务器试试。如下图所示：
            <img src="./imgs/openVPN 实现整个系统全局代理.gif" />
            <p class="img_descr">（openVPN 实现整个系统全局代理）</p>
        </p>
        <p>openVPN 方式，加之前面的在线网页代理方式和 google 服务器代理方式，解决了我 95% 的问题。openVPN 解决了 GoAgent 无法实现系统全局代理的问题，但还是有几个问题：问题一，www.vpngate.net/en 上的公共免费 VPN 经常失效，需要我重新下载新的证书，挺麻烦；问题二，这些公共免费 VPN 任何人可能轻易获取，有些按区域进行版权保护的网站会主动屏蔽从这些公共 VPN 发起的请求（这事儿跟天朝的 GFW 没关系），比如 YouTube 上的 music 频道，只能特定地域的 IP 才能观赏，从这些公共 VPN 发起的视频访问请求均被忽略。针对问题一，没什么说的，失效了又去下载新的；针对问题二，说白了，就是在线网页代理方式、google 服务器代理两类方式完全无法设定以某个指定国家或者地区的 IP 作为代理出口 IP，VPN 代理方式相对好一点，www.vpngate.net/en 多少有 20 多个国家可供选择，但仍然缺乏弹性，比如，无法选用台湾、马来西亚、瑞典的代理出口 IP。再举个例，百度音乐上的所有歌曲都是区域版权保护的（仅限大陆用户），留学国外的朋友想要听歌就悲摧了，必须得找个国内 IP，从墙外翻墙内，GoAgent 使用的是 google 在美国的服务器，用 GoAgent 肯定没戏，openVPN 可用的公共 VPN 有没有国内的。我需要可以随意指定出口 IP 的代理方式。</p>

        <h4 id="index_3_3_5">3.3.5 地下网络代理</h4>

        <p>前面介绍的几种代理方式，都有个共同的特点：第三方先贡献出一台墙外服务器，然后允许你以该服务器作为出口，访问目标网页，出口服务器在获取完整目标网页后再传回给本地。GoAgent 的出口服务器是 google 的 GAE 引擎所在服务器、openVPN 的出口服务器是各大机构免费开放的 VPN 服务器，由此可见，这些<b>出口服务器</b>是实现翻墙的关键。</p>
        <p>有报道称，接入互联网的 PC 数已达 13 亿，分布在全球各地，如果，我说如果，有某种机制，一旦建立相互信任关系后，位于墙外的 PC1 能允许墙内 PC2 将自己作为出口服务器进行目标网页访问，那也是可以实现翻墙，若是可行，13 亿台 PC，你只需选择希望的国家或地区的那台 PC 建立信任，随意指定出口 IP 的代理方案完全可以落地。tor 诞生。</p> 
        <p>顶级黑客为保证自身安全，对网络匿名访问有非常高的要求，通常：他们先在自己的 PC 上安装虚拟机，然后虚拟机中通过 VPN 代理进入 tor 的地下网络，最后从 tor 的出口中继节点发起网络访问。这样一层套一层的方式，实现了绝对的匿名访问。tor 项目初衷是为用户创建一套高度匿名网络访问的服务，任何国家、任何计算机设备均可加入将自己设置为一个中继节点，所有中继节点形成了一张巨大的地下网络，你的任何网络访问请求，均可通过这张地下网络多次中转，既实现了不可回溯的匿名访问功能，而且帮助用户可以选用任何地区的 IP 进行网络访问。接入地下网络前，tor 会让你先连接上索引服务器，由于地下网络中的中继节点数量非常多，所以必须通过索引服务器查找应该连接哪些节点；一旦连接上索引服务器，它将为你分配三个中继节点，入口中继、中转中继、出口中继，这三个中继组成一条地下网络访问路径，你的网络访问请求路径变成客户端-入口中继-中转中继-出口中继-目标网站，回到我们引入地下网络代理的背景，如何指定任意国家的 IP 进行代理访问？这看似不可能实现的任务，在 tor 中易如反掌，只需手工指定路径中的出口中继节点指定为你需要的区域即可。下面我们看下具体操作。</p>
        <p>第一步，下载并安装 tor、vidalia。tor 是命令行工具，那些被 windows 毒害的用户患有命令行恐惧症，为解救他们，开发人员在 tor 外开发了一套图形界面的壳 vidalia，这样通过 vidalia 在图形界面下操纵 tor。你可以在 www.torproject.org/dist（再一次，用前面介绍的三种代理方式翻墙访问） 找到最新版的 tor 和 vidalia 源码，下载后分别源码安装；</p>
        <p>第二步，指定出口中继节点。重点来了，我们引入 tor 地下网络的目的是想实现按自己意愿指定某个国家的 IP 作为访问代理，只要正确配置即可。tor 的配置文件，若是源码安装的，则为 /usr/local/etc/tor/torrc，若从预编译包中安装，则为 /etc/tor/torrc 或 /etc/torrc，vidalia 的配置文件为 /root/.vidalia/torrc。我们以 tor 为例，看看两种指定出口 IP 的方式。</p>
        <p>
            方式一，按国家代码进行指定，在 tor 配置文件中增加如下信息：
            <div class="sample">
                #&nbsp;按国家指定出口中继节点&nbsp;<br />
                ExitNodes&nbsp;{MY}&nbsp;<br />
                #&nbsp;严格按&nbsp;ExitNodes&nbsp;设定选用出口中继，即便没有可用中继导致创建地下网络路径失败也要严格选用&nbsp;<br />
                StrictNodes&nbsp;1<br />
            </div>
            其中，我希望出口 IP 位于马来西亚，所以在 {} 设定为 MY，你可以换成任何你希望的国家或地区，比如想要台湾 IP，可以设定为 TW，完整国家代码参见 zh.wikipedia.org/wiki/ISO_3166-1。
        </p>
        <p>
            方式二，按节点名进行指定，在 tor 配置文件中增加如下信息：
            <div class="sample">
                #&nbsp;按节点名进行指定&nbsp;<br />
                ExitNodes&nbsp;voxility,axigy1<br />
                #&nbsp;严格按&nbsp;ExitNodes&nbsp;设定选用出口中继，即便没有可用中继导致创建地下网络路径失败也要严格选用&nbsp;<br />
                StrictNodes&nbsp;1<br />
            </div>
            其中，我希望出口 IP 位于罗马尼亚，所有选用 voxility 这个出口中继节点的名字，它就位于罗马尼亚，你可以在 www.torservers.net/exits.html 找到当前各国在线的节点名，按需选用，你也可以指定多个出口节点名，用 , 分割，形成候选列表，避免单个节点故障影响你的使用。
        </p>
        <p>
            关于出口节点的选择，你一定要谨慎！不见得进入地下网络就一定安全。天朝虽无法绝对封锁 tor 的地下网络，但可以把自己隐藏到地下网络中，伪装成一个普通中继节点，这就是所谓的“蜜罐”。另外，除了天朝外还有些社会主义国家也有他们自己的 GFW，比如伊朗、叙利亚、朝鲜等等，如果，你把朝鲜选作出口节点，很好，费了九牛二虎之力翻到墙外，你会发现更多网站无法访问了，就好像你挖条地道越狱，好不容易挖通了，却发现是在隔壁监狱 @_@！因此，你需要告诉 tor 切勿选用这些国家的中继节点：
            <div class="sample">
                #&nbsp;不选用以下国家的中继节点<br />
                ExcludeNodes&nbsp;{IR},{SY},{KP},{CN},{MO},{HK}<br />
            </div>
        </p>
        <p>
            第三步，设置浏览器让其通过地下路径进行网络访问。前面介绍 GoAgent 时我们已经设置过浏览器，让浏览器走 GoAgent 代理模式，这里的设置与前面差不多，点击插件 autoproxy，进入 preferences -> proxy server -> edit proxy server -> add proxy server，添加代理名 tor、IP 为 127.0.0.1、端口为 9050、协议 socks4，保存后重启 firefox，这时你在 autoproxy 中可以看到两个可选代理，见下图：
            <img src="./imgs/在 firefox 中增加 tor 代理模式.gif" />
            <p class="img_descr">（在 firefox 中增加 tor 代理模式）</p>
        </p>
        <p>第四步，进入地下网络。tor 威力太大，近年被 GFW 彻底封杀，你用普通方式是无法接入索引服务器，你可以用网桥或者 VPN 接入。</p>
        <p>
            尝试通过网桥进入地下网络。何为网桥？地下网络中的普通中继节点是以公共形式存放在索引服务器上，网桥实际上是种私有中继节点，也就是说，你先用私有中继节点（即网桥）接入索引服务器，接着获取地下网络三个节点的网络路径，然后抛弃私有中继、采用地下网络路径进行访问。目前有两种获取网桥的方法。方法一，直接去官网获取 bridges.torproject.org/bridges，简单得很，输入验证码即可获取网桥，好吧，我承认，这是我见过最复杂的验证码，你可以把网页放大到最大程度，或许你可以看清；方法二，用你的 google 邮箱给 bridges@torproject.org 写封邮件，主题为 get bridges，内容为 bridges，邮件正文必须是纯文本，你的邮件签名应该先禁止掉，几分钟后将收到 tor 项目组自动反馈的邮件，内容正是你需要的网桥，类似：
            <div class="sample">
                88.83.241.14:9001 e040f24bfdd1e4aab4fed15db47d8c22dfac454d 
            </div>
            其中，三部分依次为网桥的 IP、网桥的端口、网桥的指纹。有了网桥，你需要将其添加进 tor 的配置文件中：<br /><br />
            <div class="sample">
                #&nbsp;使用网桥<br />
                UseBridges&nbsp;1<br />
                #&nbsp;设置网桥<br />
                Bridge&nbsp;88.83.241.14:9001&nbsp;e040f24bfdd1e4aab4fed15db47d8c22dfac454d&nbsp;&nbsp;<br />
            </div>
            这时，你可以先尝试下能否接入索引服务器，命令行执行：<br /><br />
            <div class="sample">
                tor
            </div>
            如果长时间停留在 Bootstrapped 5%: Connecting to directory server，那么说明你刚获取的网桥已经被 GFW 封锁，如下图所示：
            <img src="./imgs/网桥连接地下网络失败.gif" />
            <p class="img_descr">（网桥连接地下网络失败）</p>
            本次尝试失败！你别惊讶，想想也正常，你能轻松获取网桥，GFW 的运维人员也能轻易获取，他们可是一群天天只干这事儿的人，新出一个网桥，他们就封锁一个。你更别妥协，我们用网桥的目的是为了接入索引服务器，通过前面几节的介绍，你已经具备 VPN 系统全局代理的能力，网桥不行咱就不用网桥，你完全可以在全局代理的环境下不用网桥接入代理服务器。
        </p>
        <p>
            尝试通过 VPN 进入地下网络。先把上一步添加的网桥信息全部注释掉，然后执行 openVPN 建立系统全局代理环境，最后执行 tor 进入地下网络。如下图所示：
            <img src="./imgs/VPN 连接地下网络成功.gif" />
            <p class="img_descr">（VPN 连接地下网络成功）</p>
            尝试成功！由入口、中转、出口三个节点组成地下网络访问路径就创建好了，为确保绝对安全，tor 周期性变更路径中的三个节点，也就是说，这个时段是 node1-node2-node3 组成的路径，下个时段则变成 node11-node22-node33，达到访问不可回溯的目的。
        </p>
        <p>经过以上四步设置，以后，你要想进入地下网络，先运行 openVPN 创建 VPN 系统全局代理环境，接着运行 tor 进入 tor 地下网络，最后设置 autoproxy 走 tor 地下网络路径，搞定！你可以访问 check.torproject.org 以确认是否通过地下网络访问。</p>
        <p>好了，翻墙部分就这样了，说得多了些。就我而言，大部分时间只要浏览器能翻墙即可，虽然 GoAgent 和 OpenVPN 两种方式都可达到目的，但我优选 GoAgent，一是毕竟使用的是 google 的服务器，机器性能、网络带宽、在线时长都比免费 OpenVPN 的来的好，二是 GoAgent 只影响浏览器，不会强制让我其他应用程序（如下载工具）走代理。需要全局代理时用 openVPN，需要指定地域的出口 IP 时用 openVPN+tor。</p>

        <h3 id="index_3_4">3.4 资源下载</h3>
        <p>在我看来，优秀的下载工具至少应具备如下功能：支持主流公有下载协议（bt、ed2k、ftp）、支持通过不同协议从多个来源下载同个文件（如，你通过 ftp 协议下载文件 big_file.iso，下载工具智能分析找出其他协议在不同渠道中是否有同个 big_file.iso 文件，实现从原地址下载的同时也从所有其他可能的地址下载同个 big_file.iso）、支持断线续传，所以，老牌下载工具 wget 已无法满足需求，推荐三个下载利器推荐：aria2、MLDonkey、uGet，优选aria2，非常强大的下载利器，不过是命令行程序，以后考虑为它写个 GUI 前端，喜欢 GUI 的选用 uGet。</p>
        <p>
            如果你是在国外网络环境中，有这几个工具之一也就足够了，但在冏朝就没那么单纯了，下载一定离不开迅雷，原因有二：
            <ul>
                <li>原因一，资源仅提供迅雷私有协议下载地址。在朝内，迅雷终端占有率非常高，可以引导用户产生大量 PV 访问量，迅雷以访问量为甜头，与朝内大大小小资源下载站点组成下载联盟，让这些网站仅提供迅雷私有协议（thunder）的下载地址，这样，用户下载资源时被动使用迅雷；</li>
                <li>原因二，冷门资源迅雷独家供应。迅雷公司智能分析出大量冷门资源、容易掉种资源并预先保存到官方服务器中，一旦这些资源从公有协议下载渠道中消失，就只能通过迅雷私有协议进行下载，这样，用户下载资源时主动选用迅雷；</li>
            </ul>
        </p>
        <p>遗憾的是，迅雷仅提供 windows 版本，在 LINUX 下你是无法（直接）使用迅雷的。作为一个 LINUX 狂热用户，也不得不承认，要让电脑完全满足我日常需求，或多或少还是要借助 windows。有些 LINUXer 认为引入 windows 程序会玷污 LINUX 的纯洁性，宁愿放弃某些应用，也不愿和 windows 沾边。个人认为，任何事情不要走极端，我们玩 LINUX，是为了享受它带来的开放、自由、创新，但同时，也不要人为丢弃 windows 提供的特有服务，毕竟，我们使用电脑是为了解决实际问题，而不是向谁证明“我是一名纯正的LINUXer”，否则只会顾此失彼。当然，如果有功能类似的软件，肯定会优先选用 LINUX 版本，这点无须质疑。</p>
        <p>我们需要借助 windows，这倒不是 LINUX 系统本身不够完善，而是某些应用软件开发商只发布了 windows 版本，且那些软件又掌握着其所在领域的垄断权（两个特征：采用私有协议、用户规模大），以至于第三方即便有心也无力在LINUX下开发类似软件。对我而言，有几类应用让我离不开 windows：资源下载和网上购物。接着说下载，网购后文有提及。</p>
        <p>有什么办法能解决“在 LINUX 下使用 windows 程序”的问题呢？目前有两类解决方式：转换层方式（模拟 Windows 操作系统）和虚拟机方式（模拟计算机硬件）。在介绍这两类方式前，先了解下为什么会存在这样的移植性问题。之所以 windows 程序不能在LINUX下运行，主要因为操作系统api不同所致，类似迅雷这类应用程序，由于对性能要求高、功能要求严，所以开发时必须与操作系统非常紧密联系，采用了大量系统提供的独有 api，最终成为 windows 上的“原生应用程序”，一旦“原生应用程序”找不到对应 api，当然也就无法正常启动运行。好了，根结就在api上。</p>
        <p>我们说的第一类解决方式，是在 LINUX 中部署一套为 windows api 转换层，我们让应用程序在转换层中运行，应用程序继续调用 windows 提供的 api，转换层接收到 api 请求后将具体执行操作传递给 LINUX 系统，LINUX 执行完后返回的转换层，转换层将请求执行结果反馈给 windows 应用程序，完成一次 api 请求，这样重复往返多次不同 api 调用，最终模拟完成整个应用程序执行过程。这种方式虽然可行，但也不完美：a）操作系统本身基本就是由大量 api 组合而成，如果实现了所有 windows api 那就实现了 windows 系统，从工作量和复杂度上来说，这不是哪个开源社区能够负担得起的，所以，目前做得最好的转换层（wine，收费版本 CrossOver）也仅实现了部分 api，这意味着，不是所有 windows 程序都可以在转换层中运行，这是一个问题；b）既然是模拟 api，那么从执行效率（实时性）、执行结果（正确性）上看，肯定与直接在windows中执行存在明显差距，时常会出现程序异常退出、运行缓慢等等问题，这对实时性要求较高的应用（在线3d游戏）来说，是用户无法接受的。正因为此，不推荐该方式。</p>
        <p>第二类解决方式是安装虚拟机，在虚拟机中安装一个 windows 操作系统，这就像和你直接安装的 windows 一样，这样就有了一整套完整的 windows api，所有应用程序均可正常运行。virtualbox 就是一款著名的开源虚拟机（咱先别管它的东家：）。</p>
        <p>软件名称：virtualbox</p>
        <p>
            界面截图：
            <img src="./imgs/virtualbox中运行迅雷.png" />
            <p class="img_descr">（virtualbox中运行迅雷）</p>
        </p>
        <p>下载安装：切勿从软件仓库中安装，仓库中的版本无法识别 usb 设备，官网提供了完整版（www.virtualbox.org/wiki/LINUX_downloads）；</p>
        <p>设置调整：要像使用原生 windows 那样使用装在 virtualbox 中的 windows，必须注意以下几方面。</p>
        <p>内核管理。virtualbox 对内核版本非常敏感，一旦有内核升级，必须对 virtualbox 核心模块进行重新编译。别担心，不需要你具备程序员的能力， virtualbox 会自动执行，你，负责为它准备相关编译工具 —— gcc、make、kernel-dev。第一个是编译器，第二个是构建工具，第三个是编译内核需要的头文件，这三个工具均可通过软件仓库安装。一旦准备好相关工具，用root权限执行 /etc/init.d/vboxdrv setup 命令即可；</p>
        <p>显卡管理。要让 virtualbox 中的 windows 支持 3d 显卡加速，必须安装在 windows 中安装 virtualbox 内置增强包。增强包只有在 windows 的安全模式下才能完整安装，windows 虚拟机启动时按 f8 进入安全模式，选择 virtualbox 菜单 devices -> install guest additions 进行增强包的安装；</p>
        <p>
            USB 管理。要让 VB 完全支持 USB 设备，除了安装内置增强包外，还应安装外置增强包。VB 官网下载 VirtualBox Extension Pack 外置增强包，从 VB 控制界面 file -> preferences -> exensions 中选择安装刚下载的增强包，从 machine -> settings -> usb 中选中 enable usb controller 和 enable usb 2.0 (EHCI) controller，保存后重启主系统（对，不仅 VB 重启）。一般情况下，你插入的 USB 设备先是被主系统识别，要让客系统识别，必须在客系统中将其勾选出来，如果某个 USB 设备你只会在客系统中使用，这冗余一步未免麻烦，这时可以设置 USB 设备过滤器，让主系统自动移交控制权给客系统，比如，我的建行 U 盾 DMWZ Co. eSafeE_H，见下图设置后，它将自动出现在客系统中：
            <img src="./imgs/USB 设备过滤器.png" />
            <p class="img_descr">（USB 设备过滤器）</p>
            另外，有时你可能会遇到客系统提示无法获取 USB 设备控制权的提示“Failed to create a proxy device for the USB device. (Error: VERR_READ_ERROR)”，十有八九是你主系统中未正确设置将该设备的读写权限，给拥有者、群组、其他三类用户均分配读写权限<br/><br/>
            <div class="sample">
                chmod a=rw usbname1 usbname2
            </div>
            重启 VB 即可。
        </p>
        <p>其他说明：推荐安装 Thunder7.2.13.3882，其他版本（甚至小版本）在虚拟机中可能出现 C++ 运行期库溢出或者迅雷会员无法登录的问题。迅雷有自动升级机制，为防止版本变更引起迅雷使用问题，你必须暴力破坏迅雷的自动升级程序 ThunderLiveUD.exe，在迅雷所在的安装目录搜索该程序，找到后全量删除之。</p>
        <p>这部分内容是以迅雷为例介绍了在 LINUX 下运行 windows 应用程序的通用方法，其他应用，可以此参考。</p>


        <h3 id="index_3_5">3.5 网上购物</h3>
        <p>网上购物涉及两类操作，网银支付和在线交流，前者就是各大银行的在线支付程序，后者指的是淘宝旺旺软件，典型的两类 windows 原生应用，请参考上例在 windows 虚拟机中安装对应软件即可。唯一需要注意的 u 盾的识别，插入 u 盾后，先到 virtualbox 中 setting -> usb，勾选 enable usb controller，再到 windows 虚拟机中 devices -> usb devices 列表中选中对应 u 盾，这样，windows 就能正确识别 u 盾了。其他 usb 设备的识别与之类似；</p>
        <p>啰嗦两句网银支付。目前看来，朝内绝大部分银行仅支持 win+ie 平台在线支付，完全忽视非 windows 用户的存在，强烈谴责“为保障您的资金安全，我行建议您在 windows 操作系统中完成交易”，举着安全大旗招摇过市（windows 安全？你银行服务器莫非装的高大上 windows server 2K8），相反，国外各大银行遵循标准化，支持在各类操作系统、浏览器上进行网上交易，如，美国花旗、汇丰，更有甚者（德国的银行业），银行对外开放 API，允许用户自行开发交易程序，怎么没见这些银行发生安全事故！当然，不是所有朝内银行都是“如此重视安全”，浦发银行是少数几家支持跨平台交易的银行，大家风范，值得推荐（不过营业网点较少，二三线城市几乎没有）。www.openbanks.info 是一个专注于探讨网银跨平台主题的网站，有兴趣可以逛逛。</p>

        <h3 id="index_3_6">3.6 即时通讯</h3>
        <p>常见的 IM 工具包括飞信、qq、旺旺，这三个 IM 都有对应的 LINUX 版本，但，不论是官方发布的还是第三方通过逆向工程实现的，从功能完整性、运行稳定性、界面友好性来看，均与 windows 原生版本存在巨大差距，实际使用效果并不理想。如果的确要用，建议参照上例，在 windows 虚拟机中安装运行。</p>
        <p>或许是冏朝的 LINUX 用户量过少（LINUX 在全球桌面领域占有率仅为 2%，且主要分布在万恶的欧美等资本主义国家），国内软件开发商基本采用忽略态度，即便发布了 LINUX 版的程序，要么长年不更新（qq for LINUX 从 2009 年 1 月发布后从未更新过，im.qq.com/qq/LINUX/download.shtml）、要么不对外发布（aliwangwang for LINUX，仅用于淘宝公司内部测试，ge.tt/8sppgia），在此呼吁各大开发商，请对 LINUX 予以正确的认识和重视，尊重我们选择操作系统的权利。（不得不承认，QQ 在囧朝不仅是 IM 工具，而是一种通讯渠道，如果你真离不开它，可以考虑web qq web.qq.com）</p>

        <h2 id="index_4">4 系统管理</h2>

        <p>LINUX 系统管理是很大一个领域，有专门的一群从业者靠此养家糊口，我无法在此进行详细讲解，仅以几类常规操作抛砖引玉。</p>

        <h3 id="index_4_1">4.1 数据备份</h3>
        <p>随着对电脑的依赖，我们多多少少积累了些重要资料，可以说这些资料是形成我们“个人能力”的主要来源，一旦丢失，多年的工作经验、生活点滴均将化为烟云，这是我们一笔无形的财富。硬盘老化、操作系统异常、电脑遗失等等都会导致资料丢失，为避免损失，应该养成定期备份数据的习惯。</p>
        <p>
            就我个人经验来看，数据备份要注意以下几点：
            <ul>
                <li>第一，存放备份的介质。数据备份，不是在电脑内置硬盘上的一个分区备份到另一个分区，否则即便有所谓的备份，一旦内置硬盘出问题，原始数据和备份数据都将挂掉。建议准备两个独立硬盘（一个 500G 移动硬盘外套硬盘盒——小盘、一个 500G 台式机硬盘外套硬盘盒——大盘）用于存放双备份数据，每次备份操作时将原始数据分别备份至这两个外置硬盘中，其中，小盘保存打包压缩后的备份数据，而大盘保存直接备份数据（未打包、未压缩）且不再用于备份之外目的（数据重要性不言而喻，我个人非常看作数据备份的，花一定成本购买两个硬盘及硬盘盒用于日常备份完全值得的，当然，仁者见仁、智者见智）；</li>
                <li>第二，内置硬盘的分区。电脑内置硬盘在分区规划时，应单独创建一个文件系统，专门用于存放需要定期备份的数据（这里的几个说法容易混淆，概念澄清下，外置硬盘中用于存放备份而来数据的分区不妨称之为 backup 分区，内置硬盘中用于存放我们重要资料的需要被定期备份出去的分区称之为 data 分区）；</li>
                <li>第三，其他项。A）全备，每次将所有数据资料全量备份而非仅备有差异部分（非增备）；B）直备，保持数据资料完整目录结构，直接备份到外置硬盘的 backup 分区，说白了就是直接复制，不进行任何再加工；C）先备后删，每次备份操作，应完成本次备份后再删除老备份，避免备份过程出问题导致历史备份丢失；D）异地存放，大型生产系统均有异地灾备系统，同样，我们存放备份数据的介质已应异地存放（如，个人电脑若长期放在家里，则建议把备份介质放在单位）；E）月备，数据备份的周期要视你具体数据量和数据更新频率而定，个人而言，100G 的数据量，备份耗时差不多 1 把小时，我一般每月备份一次（小提示，将工作、生活上需要定期做的事项按不同执行周期分类梳理到一张电子表格中，不时看看，你会发现，原来我是那么井井有条——引至《爱我何需理由》，作者：自恋小王子（这是笔名，真名吴凤辉 ：-）。</li>
            </ul>
        </p>


        <h5>打包压缩备份</h5>
        <p>在备份软件方面，无须其他特殊软件，只要有 tar、gzip、bzip2 几个常见命令即可。下面依次以直接打包备份、打包压缩备份、打包压缩带进度备份三种方式，由浅入深介绍具体备份操作。</p>
        <p>
            第一步，直接打包备份。为了保持目录结构，通过采用打包命令tar进行备份。比如，将 /data/ 目录备份到名为backup_120g的外置硬盘上，备份文件命名为 data_backup.tar，那么完整命令及参数如下：
            <div class="sample">
                tar -p -P /data -cf /media/backup_120g/data_backup.tar
            </div>
            其中，-p 表示完全保持 /data/ 目录下所有文件的文件属性，-P 表示使用绝对路径（否则 tar 忽略所有路径中的第一个 /，将其转换为相对路径，并给出警告 Removing leading `/’ from member names），-cf 表示需要创建一个备份文件且命名为 backup.tar。
        </p>
        <p>
            数据备份的时间点往往是我们最为关心的信息，所以习惯上备份文件名应该加上时间戳。LINUX 的 date 命令能根据不同参数生成指定日期信息，如下命令可在备份文件名中添加备份操作发起的日期：
            <div class="sample">
                tar -p -P /data -cf /media/backup_120g/data_backup@`<b>date +%m-%d</b>`.tar
            </div>
            其中，包裹命令 date 的”`”符号是 tab 键正上方那个键，而非单引号。以指示 shell 优先执行整个命令行中该符号对包裹的命令（即，date +%m-%d）。
        </p>
        <p>
            如果外置硬盘空间有限，/data/ 中又包含部分不那么重要的数据（如，临时目录 tmp、windows 虚拟机共享目录 share_folder/），那么备份时可以将这些目录排除掉，通过 tar 的 --exclude 参数即可实现：
            <div class="sample">
                tar -p -P /data <b>--exclude=/data/misc/tmp --exclude=/data/misc/software/vm/win_7/share_folder</b> -cf /media/backup_120g/data_backup@`date +%m-%d`.tar
            </div>
            其中，--exclude 参数语法非常特殊（其他命令中的该参数也是如此），注意几点：A）命令中的所有参数必须为绝对路径而非相对路径，且不能用 ~ 等等缩写字符；B）所有路径最后不能以 / 结尾。
        </p>
        <p>
            第二步，打包压缩备份。如果排除了部分不重要数据后外置硬盘空间仍然紧张，可以考虑对打包文件进行压缩。LINUX 上常见的压缩命令包括 gzip 和 bzip2 ，由于两者采用的不同压缩算法，导致前者压缩率较低但速度较快，后者压缩率较高但速度慢，但相关用法差不多，请按需择优选用（本例以 gzip 为例，若需 bzip2 则直接替换即可）。打包和压缩是两个独立操作，写两条命令多麻烦啊！不用，借助 LINUX 强大的管道和重定向机制，可以在一条命令中以非常自然的方式实现：
            <div class="sample">
                tar -p -P -cf - /data --exclude='/data/misc/tmp' --exclude='/data/misc/software/vm/win_7/share_folder' <b>| gzip ></b> /media/backup_120g/data_backup@`date +%m-%d`.tar.gz
            </div>
            别被这些奇怪符号吓着，管道符 | 用于实现“打包一点压缩一点”，重定向符 > 用于实现“压缩一点写一点到备份文件中”，这样，串起来就是“不停打包、不停压缩、不停写文件”的流水作业，理解了吧！其中，上个命令中 -cf 后面跟的是备份文件名，本命令中改为“-”，就在告诉 shell 说，“先别急着写文件，你（shell）把我（tar）刚生成的数据流传递给后面负责压缩的兄弟（gzip），它知道该写哪个文件，谢谢哈～”。说明两点，A）你是否注意到备份文件的扩展名为 .tar.gz，不仅本例，涉及 LINUX 主题的网站提供的下载几乎都采用这种命名方式，这叫命名约定，通常来说，如果仅打包不压缩则扩展名为 .tar，如果打包且采用 gzip 压缩则扩展名为 .tar.gz，如果打包且采用 bzip2 压缩则扩展名为 .tar.bz 或 .tar.bz2；B）其实 tar 命令使用 --gzip 和 --bzip2 参数可以直接实现打包压缩，无须像上例，采用管道和重定向来实现，但，为精确显示整个备份进度率，必须采用这种变通方式，请接着看。
        </p>
        <p>
            第三步，打包压缩带进度备份。要显示备份进度，必须得事前知道待备份数据（/data/）的大小，可通过 du 命令实现：
            <div class="sample">
                du -sb /data --exclude='/data/misc/tmp' --exclude='/data/misc/software/vm/win_7/share_folder'
            </div>
            其中，-s 表示计算 /data/ 整个目录包括子目录下所有文件的大小总和，-b 表示计算结果以 byte 为单位（或者 -k、-h 等）显示，单位的精度越高，计算百分比进度时越精确。
        </p>
        <p>
            待备份目录大小知道了，如何计算进度？上面介绍过，打包、压缩、写文件都在借助管道传递数据流，如果能查看到管道中已经传递的数据量大小，用此大小除以总大小不就能显示出当前备份进度了么？铛铛铛铛哒～，pv 现身，顾名思义 pv 就是 pipe viewer，明白了吧，管道查看器，它是监测管道数据的超级武器，没事多用用、系统更健康。
            <div class="sample">
                tar -p -cf - /data --exclude='/data/misc/tmp' --exclude='/data/misc/software/vm/win_7/share_folder' | pv --size xxx | gzip > /media/backup_120g/data_backup@`date +%m-%d`.tar.gz
            </div>
            其中，xxx 部分填入前面du命令输出结果（待备份目录 /data/ 总大小），不带单位则表示以 byte 为单位（-k 以 kb 为单位、m、g、t 亦然）。效果如下：
            <img src="./imgs/可视化备份进度.png" />
            <p class="img_descr">（可视化备份进度）</p>
        </p>
        <p>
            好了，到此包括打包、压缩、排除不重要目录、打时间戳、显示进度等特性在内的 LINUX 常规备份操作就介绍完了，一条命令啰哩吧嗦说了一大堆，大妈命～～。内容是多了点，一次没看明白就多看几次，其实也不复杂，我们一起看看简化模型吧（啰嗦的平方就是在下，谢谢，：O）。
            <div class="sample">
                du&nbsp;-sk&nbsp;/source<br />
                tar&nbsp;-p&nbsp;-P&nbsp;-cf&nbsp;-&nbsp;/source&nbsp;|&nbsp;pv&nbsp;--size&nbsp;xxxk&nbsp;|&nbsp;gzip&nbsp;&gt;&nbsp;dest.tar.gz<br />
                # 若仅打包不压缩则将上条命令中的gzip改为cat即可
            </div>
        </p>
        <p>
            有备份就有恢复，相对备份操作而言，恢复就太简单了。仍用tar命令，参数不同而言：
            <div class="sample">
                tar -xv -f dest.tar.gz -C .
            </div>
            其中，-x 表示执行解压解包操作，采用哪种解压算法由 tar 自行侦测后决定，-v 表示显示以及解压出的文件列表，-f 表示该参数后面紧跟的就是待解压的文件名，-C 表示该参数后面紧跟是解压后的文件存放路径。
        </p>
        <p>这次真的说完了，没想到我对朴实的 tar 如此动情，不知不觉谈了这么多关于她的点滴。在介绍她的同时，我也再次品味到了 UNIX 哲学 —— 分工明确、各司其职、齐心协作。</p>

        <h5>直接备份数据</h5>
        <p>
            相较压缩备份，直备就简单多了。貌似 cp 配合 pv 可以实现带进度的拷贝：
            <div class="sample">
                cp src/big.file /proc/self/fd/1 | pv --size XXX | cp /proc/self/fd/0 des/back.file
            </div>
            但，实际上，由于使用了 /proc/self/fd/1，该方式只适用于拷贝单个文件，不适合整个目录，如果显示单个文件的拷贝进度，完全可用 rsync、scp 等自身就有进度显示的命令替代。其实，显示拷贝进度的算法不难，单独起个线程，实时当前拷贝总量/计算待拷贝总和，再将结果以百分百和进度条显示打印出来即可。要不咱就到 gnu.org 下载 cp 源码，自己把显示进度的代码添加进去？别急，我肯定不是第一个有此想法的人，先duckduckgo.com 下，果然有人为 cp 写了显示进度的增强补丁，直接下载后替换本地 cp 命令（zwicke.org/web/advcopy/advcpmv-0.5-8.21-static.tar.xz）。具体命令模型如下：<br /><br />
            <div class="sample">
                cp&nbsp;-grp&nbsp;src/*&nbsp;des/&nbsp;&amp;&amp;&nbsp;cp&nbsp;-grp&nbsp;src/.[^.]*&nbsp;des/&nbsp;<br />
            </div>
            简单解释下，系统自带的 cp 命令（以及 rm、mv 等）存在两个致命伤：一是上面提到的无法显示拷贝进度、剩余时间等用户关注信息，一是无法处理隐藏文件。针对问题一，用改良后的增强版 cp 命令结合其独有的 -g 命令行参数即可解决，针对问题二，需要用 src/.[^.]* 方式特殊处理，所以，上面命令中分别依次（&& 目的所在）拷贝非隐藏文件（src/*）和隐藏文件（src/.[^.]*）。
        </p>
        <p>
            拷贝大量文件的过程是否可靠？别急，直备完了再检查下数量和大小。检查待备份目录中文件数与直备目录文件数是否一致：
            <div class="sample">
                ls&nbsp;-lR&nbsp;src/&nbsp;|&nbsp;grep&nbsp;"^-"&nbsp;|&nbsp;wc&nbsp;-l&nbsp;&amp;&amp;&nbsp;ls&nbsp;-lR&nbsp;des/&nbsp;|&nbsp;grep&nbsp;"^-"&nbsp;|&nbsp;wc&nbsp;-l&nbsp;<br />
            </div>
            检查待备份目录总大小与直备目录是否一致（单位 byte）：<br /><br />
            <div class="sample">
                du&nbsp;-sb&nbsp;src/&nbsp;&amp;&amp;&nbsp;du&nbsp;-sb&nbsp;des/<br />
            </div>
        </p>
        <p>备份，介绍完毕。</p>


        <h3 id="index_4_2">4.2 碎片整理</h3>
        <p>要理解碎片，必须先了解硬盘基本结构和硬盘读写机制两个概念。之后，再看看不同操作系统写文件的策略，你自然会明白碎片在 LINUX 下是啥东东。</p>
        <p>硬盘基本结构。硬盘内部是由多张磁片和一个机械臂组成，磁片上最小单位是扇区，一旦硬盘停止工作后（如，关机），机械臂将复位到第一个扇区处。对于扇区而言，不论写入数据有多小，一旦占用了某个扇区后，其他数据就不能再写入通过扇区，即便该扇区还有空余空间（这就是为什么我们说一个大文件要比拆分为多个小文件的合计要小一些的原因）。每次读或写操作之前，机械臂先移动寻找到要访问的扇区，这个过程称之为“寻址”，由于机械臂移动是个物理动作，如果读写操作老是在不同扇区间不停移来移去，势必会增长读写操作耗时。</p>
        <p>文件布局策略，决定了是否产生磁盘碎片。</p>
        <p>
            windows 采用的文件布局策略——所有文件相互紧靠布局，相邻文件间不会出现任何空闲扇区。我们假定有 A、B、C 三个文件，按 windows 的文件管理策略，依次连续占据 0～3 号扇区、4～7 号扇区、8～9 号扇区，这时，用户编辑了文件 B，增加了文件内容，导致文件 B 体积增大了 2 个扇区的大小，由于文件 B 后紧接文件 C，此时以无空闲扇区，只能将增加部分内容写入最靠前的空闲扇区，即，10 号和 11 号两个扇区，这时，10、11 号扇区就形成了碎片。如下图所示：
            <img src="./imgs/windows文件管理策略.png" />
            <p class="img_descr">（windows文件管理策略）</p>
            以后，一旦用户需要访问文 件B，系统先寻找到 4 号扇区，将 4～7 号扇区读入内存，再寻找到 10 号扇区，将 10～11 号扇区读入内存，最后将这 6 个扇区合并供用户使用（当然，这一过程对用户是透明的）。设想一下，刚装好系统时硬盘上有 5000 个文件，其中1000个在后来系统使用过程中被人为或程序调整过大小，那么这 1000 个文件个个都被截成几段，这就形成了大量“碎片”，文件越多、文件写入次数越多，产生的碎片就越多。
        </p>
        <p>
            LINUX 采用的文件布局策略——所有文件分散布局，相邻文件间预留空闲扇区。对比上例，LINUX 在创建文件时，将文件 A 置于扇区 0～3、文件 B 置于扇区 6～9、文件 C 置于扇区 12～13，由于文件 B 和文件 C 之间有两个空闲扇区，在文件 B 增大 2 个扇区时，直接占用扇区 10 和扇区 11，不会形成碎片。如下图所示：
            <img src="./imgs/linux文件管理策略.png" />
            <p class="img_descr">（LINUX文件管理策略）</p>
        </p>
        <p>显然，按 LINUX 的策略，无论硬盘中有多少文件、写入多少次，系统基本不会产生碎片。再回到前面的问题，LINUX 碎片整理代表什么？代表没事找抽～～</p>
        <p>有童鞋问，如果文件增大扇区数大于该文件后空闲扇区数时会是啥情况？good news，LINUX 有一套智能算法，让文件分散布局得足够合理，只要文件系统使用率不超过80%，该算法基本能保证每个文件后有足够空闲扇区可用，实现零碎片；bad news，一旦使用率超过 80%，碎片仍会出现，这时，虽然少量碎片对性能有一定影响，但至少剩余的空闲磁盘资源仍然被合理利用起来了。访问缓慢、浪费空间，两害，取其轻。</p>
        <p>如果你是偏执狂，非要消除那不足 20% 文件产生的碎片，可以这样，先将该文件系统上所有文件剪切至其他文件系统，再剪切回来，可在一定程度上消除碎片。</p>


        <h2 id="index_5">5 图形图像</h2>
        <p>我们活在五彩斑斓的世界，色彩组成了世间万物。计算机是真实世界的数字扩展，当然也应该多彩绚丽。</p>

        <h3 id="index_5_1">5.1 图片编辑</h3>
        <p>玩单反的朋友用 photoshop，玩单反又玩 LINUX 的朋友用 gimp。gimp 是 LINUX 下著名的图形处理工具（同时，由它衍生出来了一种功能强大、设计灵活的通用图形库gtk，gtk 被 gnome 选作基础库，成为 gnome 环境中图形应用程序的开发标准），功能与 photoshop 不分上下。</p>
        <p>软件名称：gimp</p>
        <p>
            界面截图：后面绿色区域是桌面背景啦，另，图中大象的玩弄、抚摸以及搓揉权归属吴凤辉先生，特此声明！
            <img src="./imgs/GIMP.png" />
            <p class="img_descr">（gimp）</p>
        </p>

        <h3 id="index_5_2">5.2 色彩提取</h3>
        <p>有时看到很好的配色方案想要把色彩记录下来，这时就需要一款提取色彩值的工具。</p>
        <p>软件名称：gpick</p>
        <p>
            界面截图：
            <img src="./imgs/gpick.png" />
            <p class="img_descr">（gpick）</p>
        </p>

        <h3 id="index_5_3">5.3 屏幕截图</h3>
        <p>截图是很常用到的一种工具，我认为一个好的截图工具至少应具备能截取视频图片、能放大像素以让用户精确截图、预制常用的截图模式（即，除截取鼠标选中区域外，能针对窗口、菜单、提示气泡等直接截取）等功能点。shutter 号称 LINUX 下最强截图工具，支持我提的几点要求，值得推荐。</p>
        <p>软件名称：shutter；</p>
        <p>
            界面截图：
            <img src="./imgs/shutter.png" />
            <p class="img_descr">（shutter）</p>
        </p>
        <p>其他说明：shutter 有个小 BUG，在该软件中设置了快捷键无法生效，会报错 WARNING: DBus connection to org.freedesktop.compiz failed --> setting keyboard shortcuts may not work when using compiz。要解决该问题，可设置系统的全局快捷键，通过全局快捷键从命令行启动shutter完成不同模式截图操作：进入系统快捷键设置界面 system settings -> keyboard -> shortcuts -> custom shortcuts -> +，在 name 中输入快捷键名（如 screenshot win），command 中输入具体命令（如，shutter --window --min_at_startup），保存，点击 new accelerator，接着你点击需要设置的快捷键（如敲击 F4，不是输入 F、4 两个字符），这样即可完成 F4 调用 shutter 实现截取整个窗口的功能，同理，shutter --select --min_at_startup 截取指定区域 、shutter --full --min_at_startup 截取整个屏幕、shutter --web=http://www.csdn.net --min_at_startup 截取完整网页。另外，选择快捷键时注意不要与系统常见默认快捷键冲突。</p>


          <h3 id="index_5_4">5.4 屏幕录像</h3>
          <p>
          说了屏幕截图肯定要说屏幕录像，如果是一副图抵得上 100 个字，那么一段视频就是100 副图。录屏工具生成的视频格式非常重要，最高压缩比的视频文件体积都不小，能表达连续动作又能比视频文件体积小的文件格式是什么？gif 格式。byzanz 可以将录屏内容直接输出到 gif 文件中。byzanz 是个命令行工具，但操作不难。
          <div class="sample">
              byzanz-record -d 16 -c test.gif
          </div>
          其中，-d 表示以秒为单位的录屏时长，-c 表示包括录制鼠标。
          </p>
          <p>真心喜欢这个软件，但受限于需要手工指定屏幕位置以及录屏时长，灵活性相对欠缺。就我而言，存在三个硬伤。</p>
          <p>
          硬伤一，无法针对选定区域录屏。byzanz 支持在命令行参数中输入屏幕坐标来指定录屏区域，这在实际操作过程中非常麻烦。如果有个命令行程序可以获取鼠标在屏幕上拖拉矩形区域的坐标，并输出坐标结果，那么不就可以将坐标输出给 byzanz，实现对指定区域录屏的效果。一翻搜索后，果然找到名为 xrectsel 的工具（https://github.com/lolilolicon/FFcast2），下载安装好。结合 byzanz 和 xrectsel 写了个脚本 byzanz-record-region.sh 实现针对选定区域录屏，代码如下：
          <div class="sample">
              #!/bin/bash<br />
              <br />
              #&nbsp;recording&nbsp;duration<br />
              DURA=256<br />
              <br />
              #&nbsp;output&nbsp;file&nbsp;name<br />
              RANDOMSTR=$(cat&nbsp;/dev/urandom&nbsp;|&nbsp;tr&nbsp;-dc&nbsp;'a-zA-Z0-9'&nbsp;|&nbsp;fold&nbsp;-w&nbsp;4&nbsp;|&nbsp;head&nbsp;-n&nbsp;1)<br />
              OUTPUT="record_screen($RANDOMSTR).gif"<br />
              <br />
              #&nbsp;Sound&nbsp;notification&nbsp;to&nbsp;let&nbsp;one&nbsp;know&nbsp;when&nbsp;recording&nbsp;is&nbsp;about&nbsp;to&nbsp;start&nbsp;(and&nbsp;ends)<br />
              beep()&nbsp;{<br />
              &nbsp;&nbsp;&nbsp;&nbsp;paplay&nbsp;/usr/share/sounds/KDE-Im-Irc-Event.ogg&nbsp;&amp;<br />
              }<br />
              <br />
              echo&nbsp;'choose&nbsp;region&nbsp;by&nbsp;mouse&nbsp;...'<br />
              <br />
              ARGUMENTS=$(xrectsel&nbsp;"--x=%x&nbsp;--y=%y&nbsp;--width=%w&nbsp;--height=%h")<br />
              if&nbsp;[&nbsp;0&nbsp;-ne&nbsp;"$?"&nbsp;]<br />
              then<br />
              &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;'ERROR!&nbsp;command&nbsp;xrectsel&nbsp;execute&nbsp;failure.&nbsp;maybe&nbsp;you&nbsp;have&nbsp;not&nbsp;install&nbsp;xrectsel (https://github.com/lolilolicon/FFcast2)&nbsp;at&nbsp;all.&nbsp;check&nbsp;it.&nbsp;'<br />
              &nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1<br />
              fi<br />
              <br />
              echo&nbsp;"byzanz&nbsp;will&nbsp;start&nbsp;to&nbsp;record&nbsp;$DURA&nbsp;seconds&nbsp;after&nbsp;4&nbsp;seconds,&nbsp;[ctrl-c]&nbsp;stop."<br />
              sleep&nbsp;4<br />
              echo&nbsp;'BEGIN&nbsp;&gt;&gt;&gt;&gt;'<br />
              <br />
              #&nbsp;catch&nbsp;the&nbsp;ctrl-c,&nbsp;to&nbsp;tell&nbsp;byzanz&nbsp;stop<br />
              trap&nbsp;'echo&nbsp;"&nbsp;"'&nbsp;2<br />
              <br />
              beep<br />
              byzanz-record&nbsp;--cursor&nbsp;--delay=0&nbsp;--duration=$DURA&nbsp;${ARGUMENTS}&nbsp;$OUTPUT&nbsp;2&gt;/dev/null<br />
              beep<br />
              echo&nbsp;"END&nbsp;&lt;&lt;&lt;&lt;"<br />
              echo&nbsp;"you&nbsp;get&nbsp;$OUTPUT"<br />
          </div>
          </p>
          <p>
          硬伤二，无法针对指定窗口录屏。有了前面的思路，我们只需找个能获取指定窗口坐标的命令行工具，将坐标结果输入给 byzanz 即可。搜索下，有个 xwininfo 的工具，结合 byzanz，写了个脚本 byzanz-record-window.sh 实现针对指定窗口录屏，代码如下：
          <div class="sample">
              #!/bin/bash<br />
              <br />
              #&nbsp;recording&nbsp;duration<br />
              DURA=256<br />
              <br />
              #&nbsp;output&nbsp;file&nbsp;name<br />
              RANDOMSTR=$(cat&nbsp;/dev/urandom&nbsp;|&nbsp;tr&nbsp;-dc&nbsp;'a-zA-Z0-9'&nbsp;|&nbsp;fold&nbsp;-w&nbsp;4&nbsp;|&nbsp;head&nbsp;-n&nbsp;1)<br />
              OUTPUT="record_screen($RANDOMSTR).gif"<br />
              <br />
              #&nbsp;Sound&nbsp;notification&nbsp;to&nbsp;let&nbsp;one&nbsp;know&nbsp;when&nbsp;recording&nbsp;is&nbsp;about&nbsp;to&nbsp;start&nbsp;(and&nbsp;ends)<br />
              beep()&nbsp;{<br />
              &nbsp;&nbsp;&nbsp;&nbsp;paplay&nbsp;/usr/share/sounds/KDE-Im-Irc-Event.ogg&nbsp;&amp;<br />
              }<br />
              <br />
              echo&nbsp;'choose&nbsp;windows&nbsp;by&nbsp;mouse&nbsp;...'<br />
              <br />
              XWININFO=$(xwininfo)<br />
              read&nbsp;X&nbsp;&lt;&nbsp;&lt;(awk&nbsp;-F:&nbsp;'/Absolute&nbsp;upper-left&nbsp;X/{print&nbsp;$2}'&nbsp;&lt;&lt;&lt;&nbsp;"$XWININFO")<br />
              read&nbsp;Y&nbsp;&lt;&nbsp;&lt;(awk&nbsp;-F:&nbsp;'/Absolute&nbsp;upper-left&nbsp;Y/{print&nbsp;$2}'&nbsp;&lt;&lt;&lt;&nbsp;"$XWININFO")<br />
              read&nbsp;W&nbsp;&lt;&nbsp;&lt;(awk&nbsp;-F:&nbsp;'/Width/{print&nbsp;$2}'&nbsp;&lt;&lt;&lt;&nbsp;"$XWININFO")<br />
              read&nbsp;H&nbsp;&lt;&nbsp;&lt;(awk&nbsp;-F:&nbsp;'/Height/{print&nbsp;$2}'&nbsp;&lt;&lt;&lt;&nbsp;"$XWININFO")<br />
              <br />
              echo&nbsp;"byzanz&nbsp;will&nbsp;start&nbsp;to&nbsp;record&nbsp;$DURA&nbsp;seconds&nbsp;after&nbsp;4&nbsp;seconds,&nbsp;[ctrl-c]&nbsp;stop."<br />
              sleep&nbsp;4<br />
              echo&nbsp;'BEGIN&nbsp;&gt;&gt;&gt;&gt;'<br />
              <br />
              #&nbsp;catch&nbsp;the&nbsp;ctrl-c,&nbsp;to&nbsp;tell&nbsp;byzanz&nbsp;stop<br />
              trap&nbsp;'echo&nbsp;"&nbsp;"'&nbsp;2<br />
              <br />
              beep<br />
              byzanz-record&nbsp;--cursor&nbsp;--delay=0&nbsp;--duration=$DURA&nbsp;--x=$X&nbsp;--y=$Y&nbsp;--width=$W&nbsp;--height=$H&nbsp;$OUTPUT&nbsp;2&gt;/dev/null<br />
              beep<br />
              echo&nbsp;"END&nbsp;&lt;&lt;&lt;&lt;"<br />
              echo&nbsp;"you&nbsp;get&nbsp;$OUTPUT"<br />
          </div>
          </p>
          <p>硬伤三，无法按需主动停止录屏。byzanz 是实时写文件，所以直接 ctrl-c 中断任务即可。</p>
          <p>以后，要对窗口录屏可运行 ./byzanz-record-window.sh 脚本，要对选择区域录屏可运行 ./byzanz-record-region.sh，输出结果位于当前工作目录中。</p>

          <h2 id="index_6">6 其他杂项</h2>
          <p>前面介绍了各种常用软件，除此之外，还有些我个人经常用到但有不能归入前面分类中的软件，暂且放置于此。</p>

          <h3 id="index_6_1">6.1 蓝牙收发</h3>
          <p>电脑与手机通过蓝牙协议收发文件是最常见的蓝牙应用场景之一，下面将以笔记本电脑和手机收发图片为例进行介绍。</p>
          <p>
          openSUSE 默认已经安装好相关蓝牙管理程序（核心程序 gnome-bluetooth 和 bluez），请确认正确、完整安装。在开始之前，我们先要进行文件共享设置，以便笔记本接收手机发送的图片。运行 personal file sharing 程序，按参照下图选中所有勾选框：
          <img src="./imgs/允许蓝牙接收文件.png" />
          <p class="img_descr">（允许蓝牙接收文件）</p>
          </p>
          <p>就蓝牙收发图片的一般流程而言，我们先配对好两个蓝牙设备，在源设备中选中图片，选择通过蓝牙发送给目的设备，目的设备接收文件。但，openSUSE 蓝牙程序的 bug，如果我们以待发送文件为操作对象进行发送操作，那么系统将提示失败，换言之，不论我是从笔记本发送到手机，还是从手机发送到笔记本，只要选择文件再通过（笔记本或手机）菜单“经蓝牙发送”均会失败，必须通过另一种变通方式来实现蓝牙收发文件——手机存储浏览。也就是说，不管笔记本或手机哪个是源、哪个是目的，我们都应该先通过蓝牙浏览手机存储（如，手机的 micro-sd 卡），然后像在笔记本自身移动图片一样，通过复制、粘贴方式在笔记本硬盘与手机存储卡之间移动图片，从而实现笔记本与手机间通过蓝牙相互收发文件。</p>
          <p>具体演示步骤如下。</p>
          <p>
          首先，运行 bluetooth，出现如下界面：
          <img src="./imgs/未添加配对蓝牙设备.png" />
          <p class="img_descr">（未添加配对蓝牙设备）</p>
          </p>
          <p>
          然后，点击“+”添加配对手机：
          <img src="./imgs/添加手机“李大舅”.png" />
          <p class="img_descr">（添加手机“李大舅”：-）</p>
          </p>
          <p>
          接着，点击右下角 browse files... 浏览手机存储卡，下图为手机存储文件列表：
          <img src="./imgs/手机存储卡文件列表.png" />
          <p class="img_descr">（手机存储卡文件列表）</p>
          </p>
          <p>最后，后续在笔记本和手机目录间剪切文件即可实现蓝牙文件传送。</p>
          <p>随便说下，为增强系统的安全性，平时不需要时最好将蓝牙关闭（笔记本和手机都关了），省电不说，至少其他人看不到你设备上的任何资料，个人隐私还是要注意滴～</p>

          <h3 id="index_6_2">6.2 手机管理</h3>
          <p>不用羡慕 windows 下的各色 XX 手机助手，只要你是 android 手机，手机与 PC 在同个局域网内，那么可由 AirDroid 软件实现 android 手机的远程管理。为便于描述，我们将被管理的 android 手机称之为被管手机，将远程控制被管手机的终端称之为控制端。具体操作步骤如下：</p>
          <p>
          第一步，在被管端运行 AirDroid，程序将随机生成控制端访问该被管端的验证码，以及控制端访问的 IP（用于无互联网环境）和 URL（用于有互联网环境）地址。如下图所示：
          <img src="./imgs/被管端生成验证码.png" />
          <p class="img_descr">（被管端生成验证码）</p>
          </p>
          <p>
          第二步，在控制端用浏览器访问 web.airdroid.com，并输入上面的验证码：
          <img src="./imgs/控制端输入验证码.png" />
          <p class="img_descr">（控制端输入验证码）</p>
          </p>
          <p>
          第三步，在控制端随心控制被管端：
          <img src="./imgs/控制被管端.png" />
          <p class="img_descr">（控制被管端）</p>
          </p>
          <p>再发散思维两点：1）控制端类型不限（PC、手机、pad 等等），操作系统不限（LINUX、mac、windows 等等），你可以用 openSUSE 笔记本作为控制端、可以用windows phone 手机作为控制端、甚至可以用 iphone 作为控制端，只要能正常运行浏览器即可。换言之，由于苹果移动设备未开放蓝牙功能导致一直无法让老婆的 iphone 手机与你的 android 手机之间传输相片的问题将被 AirDroid 完美解决；2）控制端与被管端只需在同个局域网内，不一定非要访问互联网。</p>

          <h3 id="index_6_3">6.3 英文翻译</h3>
          <p>不管你英文有多好，难免会遇到几个生词，如果每次都复制粘贴到百度中搜索中文解释那多麻烦啊，英文翻译工具必不可少（当然也可以翻译其他语言，只要安装了对应词典文件）。</p>
          <p>软件名称：stardict</p>
          <p>
          界面截图：
          <img src="./imgs/stardict.png" />
          <p class="img_descr">（stardict）</p>
          </p>
          <p>设置调整：A）stardict 自带词典单词量不够，可以网上下载不同语种、不同领域的专业词典（由于字典版权问题，官网 www.stardict.cn 和项目主页 stardict.sourceforge.net 均无法下载，幸好有网友备份了abloz.com/huzheng/stardict-dic），下载后复制到 /usr/share/stardict/dic/ 目录，重启 stardict 即可生效；B）stardict 支持发音功能，但作适当调整。进入 dictionary -> sound，勾选 enable sound event 和 enable TTS program，并将 command for playing sound files: 设置为 aplay。</p>
          <p>使用问题：stardict 的选词翻译是提升翻译效率的好功能，用鼠标选中某个单词或短语，stardict 自动提取选中内容并提交后台翻译引擎，再以浮窗显示翻译结果，但有时我们选中单词中有标点符号时，stardict 将无法识别。比如，选择内容为 green:，而 stardict 严格匹配 green，将无法翻译 green:。其实，优化下取词内容代码，对取词内容适当降噪应该不难，有时间我写个补丁。</p>

          <h3 id="index_6_4">6.4 中文输入</h3>
          <p>
          个人认为影响 LINUX 在朝内推广的最大阻碍要算输入法。LINUX 下常见输入法有 scim、fictx、ibus。scim 是老牌输入法，但项目几乎停滞，长年不见更新；fictx，俗称小企鹅输入法，有一定用户量；ibus，gnome 唯一官方集成的中文输入法，有模糊拼音、常用词汇、智能匹配、主动学习、快速输入日期（rq）和时间（sj）、快速输入英文单词（v）等特点，很好用。严格地说，ibus 是输入法框架，必须在此框架中选用拼音、五笔等输入法才能正常输入。如下图所示：
          <img src="./imgs/ibus 中文输入法.gif" />
          <p class="img_descr">（ibus 中文输入法）</p>
          </p>

          <h3 id="index_6_5">6.5 软件开发</h3>
          <p>
          这个时代，上规模的软件项目已不可能用简单的文本编辑器完成，IDE 是必然选择。LINUX 下 IDE 大致分为两类：品牌机和组装机。品牌机中有些（开源）产品还不错，比如：codeblocks、netbeans、eclipse、anjuta 等等，对于初涉 LINUX 开发的朋友而言是个不错的选择（我指的是 codeblocks），但对于老鸟来说总有这样那样的欠缺。听闻 linus torvalds 这类大牛用的是类 emacs 和一堆插件拼装而成的 IDE，为向大牛致敬，加之那颗“喜欢折腾”的心，组装机是我的选择。首要任务，选择编辑器。LINUX 上存在两种编辑器：神之编辑器 emacs，编辑器之神 vim。关于 emacs 与 vim 孰轻谁重之争已是世纪话题，我无意参与其中，在我眼里，二者都是创世纪的优秀编辑器，至少在这个领域作到了极致，它们让世人重新认识了编辑操作的本质——用命令而非键盘——去完成编辑任务。我是人类，选用 vim。（...此处省略64页半...），详见《所需即所获：像 IDE 一样使用 vim》（www.yangyangwithgnu.net/computer/article/use_vim_as_ide/use_vim_as_ide.htm），作者是帅鸽 ^_*。基于该文配置后，vim 可实现如下 IDE 效果：
          <img src="./imgs/vim IDE总览.png" />
          <p class="img_descr">（vim IDE总览）</p>
          </p>

          <h3 id="index_6_6">6.6 虚拟终端</h3>
          <p>命令行，是体现 LINUX 强大的主要渠道，是驾驭 LINUX 的缰绳。在服务器领域， 99% 的任务只能依靠命令行执行完成，即便在现代桌面领域中，至少也有 30% 的任务离不开命令行。gnome3 自带虚拟终端是我操纵命令行的唯一环境，支持复制粘贴、支持多tab、支持外观自定义等等功能已经满足我日常需要。另外，介绍几个有用的命令行快捷键，将在一定程度上将提高你的效率：ctrl-c，结束当前进程；ctrl-z，挂起当前进程；ctrl-d，结束输入；ctrl-shift-c，拷贝选中文本；ctrl-shift-v，粘贴文本；ctrl-w，删除光标左边的一个单词；ctrl-w，删除当前行；ctrl-a，光标移至行首；ctrl-e，光标移至行尾。</p>

          <h3 id="index_6_7">6.7 升级BIOS</h3>
          <p>为减少硬件故障率，定期升级 BIOS 是非常有必要的。一般而言，PC 厂商只发布 windows 版本和 dos 版本的 BIOS 升级程序，并无 LINUX 版本。LINUX 环境中倒是有个刷 BIOS 的开源工具叫 flashrom，但该工具支持的芯片有限，即便对于支持的芯片，风险也比在 windows 下高得多，对于刷 BIOS 这种高危操作，一旦失败将导致无法开机甚至机器报废，必须找一种安全保险的作法。</p>
          <p>换个思路，既然你 PC 官网提供了 windows 版本和 dos 版本的 BIOS 升级程序，说明只要我们能提供 win 或 dos 环境，那么升级程序就能运行。在只装有 LINUX 的机器上，有三种提供 win 环境的方式：</p>
          <p>方式一，前面介绍过 windows 虚拟机，但，BIOS 升级程序会先判断机器芯片是否匹配升级要求，由于运行在 virtualbox 中，所以升级程序只会读取到 virtualbox 伪装后的硬件信息，并非真实机器芯片信息，所以，通常来说，升级程序会提示你芯片不匹配后自动退出。该方式不可行，无法采纳；</p>
          <p>方式二，再装个 windows，与现有 LINUX 形成双系统，进入新装的 windows 中进行 BIOS 升级操作。该方式可行，但耽误时间、浪费空间、污染环境，不想采纳；</p>
          <p>方式三，我们知道，为让 windows 用户体验 LINUX，各大发行套件厂商有各自的 live-cd 或 live-usb，这就是让用户不用实际安装 LINUX 但又能使用 LINUX 的一种技术，同理，是否有所谓的 windows live-usb 呢？当然有，WinPE（Windows Preinstallation Environment），windows 预安装环境，朝内有人基于WinPE进行封装开发了一款名为“老毛桃U盘启动盘制作工具”的软件（www.laomaotao.net），通过该软件可提供 Windows 环境。该方式简单、方便，优先采纳。</p>
          <p>由于“老毛桃 U 盘启动盘制作工具”是个 windows 软件，先需要在 win 虚拟机中下载并安装，再插入 U 盘保证虚拟机中的 win 系统能正确识别（若有问题请见前面虚拟机中相关描述章节），然后在 win 中运行“老毛桃”将 U 盘制作成 windows live-usb，最后将 BIOS 升级程序拷贝至U盘中。重启机器，U 盘引导进 windows 预安装环境，运行升级程序即可完成 BIOS 升级操作。（另，如果是 dos 版的BIOS升级程序，方法类似，只是在 U 盘引导完成后的提示界面中，选择进入 dos 环境而非 WinPE 环境）。</p>

          <h3 id="index_6_8">6.8 有待提升</h3>
          <p>讲了这么多，不是说 openSUSE 就很完美了，有些细节做得还不到位，有提升空间。如，显示器亮度调节问题，只有在纯命令行（非图形界面的模拟终端）下有效；又如，系统休眠（非待机）时不能连接有外设（音响、耳机、U 盘等等），不能在低电量时休眠，否则都有一定几率夯机；再如，多屏幕投影时，无法实现多个屏幕内容一致。如此等等，虽大方面不影响使用，但如果发行商能及时修正，在这个各大发行套件血拼的时代，谁重视用户体验，谁就会赢得人心。</p>

          <h2 id="index_7">7 完结</h2>
          <p>一旦决定移居 LINUX，你得入乡随俗：查看自带手册熟悉软件操作、借助命令行弥补图形界面不足、多用键盘少用鼠标提升操作效率、了解并遵循不成文约定习惯、修改源码让软件满足你特殊需求、明白没有最好只有最适合的道理、取至社区并回馈社区、保持一颗热爱折腾的心。总之，thinking in LINUX。</p>
          <p>LINUX 下的惬意生活，美丽新世界！</p> 

        </body>

</html>
